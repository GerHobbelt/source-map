{"version":3,"sources":["webpack://sourceMap/webpack/universalModuleDefinition","webpack://sourceMap/webpack/bootstrap","webpack://sourceMap/./lib/util.js","webpack://sourceMap/./lib/source-map-generator.js","webpack://sourceMap/./lib/base64-vlq.js","webpack://sourceMap/./lib/array-set.js","webpack://sourceMap/./source-map.js","webpack://sourceMap/./lib/base64.js","webpack://sourceMap/./lib/mapping-list.js","webpack://sourceMap/./lib/source-map-consumer.js","webpack://sourceMap/./lib/binary-search.js","webpack://sourceMap/./lib/quick-sort.js","webpack://sourceMap/./lib/source-node.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","getArg","aArgs","aName","aDefaultValue","arguments","length","Error","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","MAX_CACHED_INPUTS","normalize","f","cache","input","temp","result","unshift","pop","lruMemoize","aPath","isAbsolute","parts","start","indexOf","push","slice","part","up","splice","join","aRoot","aPathUrl","aRootUrl","joined","charAt","replace","test","relative","level","index","lastIndexOf","Array","substr","supportsNullProto","identity","isProtoString","charCodeAt","strcmp","aStr1","aStr2","toSetString","aStr","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","source","originalLine","originalColumn","generatedColumn","generatedLine","compareByGeneratedPositionsDeflated","onlyCompareGenerated","compareByGeneratedPositionsInflated","parseSourceMapInput","str","JSON","parse","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","parsed","substring","base64VLQ","util","ArraySet","MappingList","SourceMapGenerator","this","_file","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","_version","fromSourceMap","aSourceMapConsumer","generator","file","eachMapping","mapping","newMapping","generated","line","column","original","addMapping","sources","forEach","sourceFile","sourceRelative","has","add","content","sourceContentFor","setSourceContent","_validateMapping","String","aSourceFile","aSourceContent","keys","applySourceMap","aSourceMapPath","newSources","toArray","newNames","unsortedForEach","originalPositionFor","aGenerated","aOriginal","aSource","stringify","_serializeMappings","next","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","mappings","len","encode","_generateSourcesContent","aSources","aSourceRoot","map","toJSON","version","names","sourcesContent","toString","base64","aValue","digit","encoded","vlq","toVLQSigned","VLQ_BASE","decode","aIndex","aOutParam","continuation","shifted","strLen","shift","rest","hasNativeMap","Map","_array","_set","fromArray","aArray","aAllowDuplicates","set","size","getOwnPropertyNames","sStr","isDuplicate","idx","at","aIdx","SourceMapConsumer","SourceNode","intToCharMap","split","number","TypeError","charCode","_sorted","_last","aCallback","aThisArg","aMapping","lineA","lineB","columnA","columnB","sort","binarySearch","quickSort","aSourceMap","aSourceMapURL","sourceMap","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","_absoluteSources","_sourceMapURL","Mapping","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","consumer","__generatedMappings","configurable","_sortGeneratedMappings","__originalMappings","_sortOriginalMappings","__generatedMappingsUnsorted","_parseMappings","__originalMappingsUnsorted","_charIsMappingSeparator","_generatedMappingsUnsorted","_originalMappingsUnsorted","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","aContext","aOrder","context","_generatedMappings","_originalMappings","allGeneratedPositionsFor","needle","_findSourceIndex","_findMapping","undefined","lastColumn","relativeSource","smc","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","segment","end","cachedSegments","originalMappings","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","search","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","hasContentsOfAllSources","some","sc","nullOnMissing","fileUriAbsPath","generatedPositionFor","constructor","j","sectionIndex","section","bias","every","generatedPosition","sectionMappings","adjustedMapping","aHaystack","aCompare","recursiveSearch","aLow","aHigh","mid","Math","floor","random","swap","ary","x","y","doQuickSort","comparator","low","high","round","pivot","q","REGEX_NEWLINE","isSourceNode","aLine","aColumn","aChunks","children","sourceContents","fromStringWithSourceMap","aGeneratedCode","aRelativePath","node","remainingLines","remainingLinesIndex","shiftNextLine","getNextLine","lastGeneratedLine","lastMapping","code","nextLine","addMappingWithCode","aChunk","isArray","chunk","prepend","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","walkSourceContents","toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","sourceContent"],"mappings":"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","file":"source-map.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sourceMap\"] = factory();\n\telse\n\t\troot[\"sourceMap\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\n/**\r\n * This is a helper function for getting values from parameter/options\r\n * objects.\r\n *\r\n * @param args The object we are extracting values from\r\n * @param name The name of the property we are getting.\r\n * @param defaultValue An optional value to return if the property is missing\r\n * from the object. If this is not specified and the property is missing, an\r\n * error will be thrown.\r\n */\r\nfunction getArg(aArgs, aName, aDefaultValue) {\r\n  if (aName in aArgs) {\r\n    return aArgs[aName];\r\n  } else if (arguments.length === 3) {\r\n    return aDefaultValue;\r\n  } else {\r\n    throw new Error('\"' + aName + '\" is a required argument.');\r\n  }\r\n}\r\nexports.getArg = getArg;\r\n\r\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\r\nvar dataUrlRegexp = /^data:.+\\,.+$/;\r\n\r\nfunction urlParse(aUrl) {\r\n  var match = aUrl.match(urlRegexp);\r\n  if (!match) {\r\n    return null;\r\n  }\r\n  return {\r\n    scheme: match[1],\r\n    auth: match[2],\r\n    host: match[3],\r\n    port: match[4],\r\n    path: match[5]\r\n  };\r\n}\r\nexports.urlParse = urlParse;\r\n\r\nfunction urlGenerate(aParsedUrl) {\r\n  var url = \"\";\r\n  if (aParsedUrl.scheme) {\r\n    url += aParsedUrl.scheme + \":\";\r\n  }\r\n  url += \"//\";\r\n  if (aParsedUrl.auth) {\r\n    url += aParsedUrl.auth + \"@\";\r\n  }\r\n  if (aParsedUrl.host) {\r\n    url += aParsedUrl.host;\r\n  }\r\n  if (aParsedUrl.port) {\r\n    url += \":\" + aParsedUrl.port;\r\n  }\r\n  if (aParsedUrl.path) {\r\n    url += aParsedUrl.path;\r\n  }\r\n  return url;\r\n}\r\nexports.urlGenerate = urlGenerate;\r\n\r\nconst MAX_CACHED_INPUTS = 32;\r\n\r\n/**\r\n * Takes some function `f(input) -> result` and returns a memoized version of\r\n * `f`.\r\n *\r\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\r\n * memoization is a dumb-simple, linear least-recently-used cache.\r\n */\r\nfunction lruMemoize(f) {\r\n  const cache = [];\r\n\r\n  return function(input) {\r\n    for (var i = 0; i < cache.length; i++) {\r\n      if (cache[i].input === input) {\r\n        var temp = cache[0];\r\n        cache[0] = cache[i];\r\n        cache[i] = temp;\r\n        return cache[0].result;\r\n      }\r\n    }\r\n\r\n    var result = f(input);\r\n\r\n    cache.unshift({\r\n      input,\r\n      result\r\n    });\r\n\r\n    if (cache.length > MAX_CACHED_INPUTS) {\r\n      cache.pop();\r\n    }\r\n\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * Normalizes a path, or the path portion of a URL:\r\n *\r\n * - Replaces consecutive slashes with one slash.\r\n * - Removes unnecessary '.' parts.\r\n * - Removes unnecessary '<dir>/..' parts.\r\n *\r\n * Based on code in the Node.js 'path' core module.\r\n *\r\n * @param aPath The path or url to normalize.\r\n */\r\nvar normalize = lruMemoize(function normalize(aPath) {\r\n  var path = aPath;\r\n  var url = urlParse(aPath);\r\n  if (url) {\r\n    if (!url.path) {\r\n      return aPath;\r\n    }\r\n    path = url.path;\r\n  }\r\n  var isAbsolute = exports.isAbsolute(path);\r\n\r\n  // Split the path into parts between `/` characters. This is much faster than\r\n  // using `.split(/\\/+/g)`.\r\n  var parts = [];\r\n  var start = 0;\r\n  var i = 0;\r\n  while (true) {\r\n    start = i;\r\n    i = path.indexOf(\"/\", start);\r\n    if (i === -1) {\r\n      parts.push(path.slice(start));\r\n      break;\r\n    } else {\r\n      parts.push(path.slice(start, i));\r\n      while (i < path.length && path[i] === \"/\") {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\r\n    part = parts[i];\r\n    if (part === \".\") {\r\n      parts.splice(i, 1);\r\n    } else if (part === \"..\") {\r\n      up++;\r\n    } else if (up > 0) {\r\n      if (part === \"\") {\r\n        // The first part is blank if the path is absolute. Trying to go\r\n        // above the root is a no-op. Therefore we can remove all '..' parts\r\n        // directly after the root.\r\n        parts.splice(i + 1, up);\r\n        up = 0;\r\n      } else {\r\n        parts.splice(i, 2);\r\n        up--;\r\n      }\r\n    }\r\n  }\r\n  path = parts.join(\"/\");\r\n\r\n  if (path === \"\") {\r\n    path = isAbsolute ? \"/\" : \".\";\r\n  }\r\n\r\n  if (url) {\r\n    url.path = path;\r\n    return urlGenerate(url);\r\n  }\r\n  return path;\r\n});\r\nexports.normalize = normalize;\r\n\r\n/**\r\n * Joins two paths/URLs.\r\n *\r\n * @param aRoot The root path or URL.\r\n * @param aPath The path or URL to be joined with the root.\r\n *\r\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\r\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\r\n *   first.\r\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\r\n *   is updated with the result and aRoot is returned. Otherwise the result\r\n *   is returned.\r\n *   - If aPath is absolute, the result is aPath.\r\n *   - Otherwise the two paths are joined with a slash.\r\n * - Joining for example 'http://' and 'www.example.com' is also supported.\r\n */\r\nfunction join(aRoot, aPath) {\r\n  if (aRoot === \"\") {\r\n    aRoot = \".\";\r\n  }\r\n  if (aPath === \"\") {\r\n    aPath = \".\";\r\n  }\r\n  var aPathUrl = urlParse(aPath);\r\n  var aRootUrl = urlParse(aRoot);\r\n  if (aRootUrl) {\r\n    aRoot = aRootUrl.path || \"/\";\r\n  }\r\n\r\n  // `join(foo, '//www.example.org')`\r\n  if (aPathUrl && !aPathUrl.scheme) {\r\n    if (aRootUrl) {\r\n      aPathUrl.scheme = aRootUrl.scheme;\r\n    }\r\n    return urlGenerate(aPathUrl);\r\n  }\r\n\r\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\r\n    return aPath;\r\n  }\r\n\r\n  // `join('http://', 'www.example.com')`\r\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\r\n    aRootUrl.host = aPath;\r\n    return urlGenerate(aRootUrl);\r\n  }\r\n\r\n  var joined =\r\n    aPath.charAt(0) === \"/\"\r\n      ? aPath\r\n      : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\r\n\r\n  if (aRootUrl) {\r\n    aRootUrl.path = joined;\r\n    return urlGenerate(aRootUrl);\r\n  }\r\n  return joined;\r\n}\r\nexports.join = join;\r\n\r\nexports.isAbsolute = function(aPath) {\r\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\r\n};\r\n\r\n/**\r\n * Make a path relative to a URL or another path.\r\n *\r\n * @param aRoot The root path or URL.\r\n * @param aPath The path or URL to be made relative to aRoot.\r\n */\r\nfunction relative(aRoot, aPath) {\r\n  if (aRoot === \"\") {\r\n    aRoot = \".\";\r\n  }\r\n\r\n  aRoot = aRoot.replace(/\\/$/, \"\");\r\n\r\n  // It is possible for the path to be above the root. In this case, simply\r\n  // checking whether the root is a prefix of the path won't work. Instead, we\r\n  // need to remove components from the root one by one, until either we find\r\n  // a prefix that fits, or we run out of components to remove.\r\n  var level = 0;\r\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\r\n    var index = aRoot.lastIndexOf(\"/\");\r\n    if (index < 0) {\r\n      return aPath;\r\n    }\r\n\r\n    // If the only part of the root that is left is the scheme (i.e. http://,\r\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\r\n    // have exhausted all components, so the path is not relative to the root.\r\n    aRoot = aRoot.slice(0, index);\r\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\r\n      return aPath;\r\n    }\r\n\r\n    ++level;\r\n  }\r\n\r\n  // Make sure we add a \"../\" for each component we removed from the root.\r\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\r\n}\r\nexports.relative = relative;\r\n\r\nvar supportsNullProto = (function() {\r\n  var obj = Object.create(null);\r\n  return !(\"__proto__\" in obj);\r\n})();\r\n\r\nfunction identity(s) {\r\n  return s;\r\n}\r\n\r\n/**\r\n * Because behavior goes wacky when you set `__proto__` on objects, we\r\n * have to prefix all the strings in our set with an arbitrary character.\r\n *\r\n * See https://github.com/mozilla/source-map/pull/31 and\r\n * https://github.com/mozilla/source-map/issues/30\r\n *\r\n * @param String aStr\r\n */\r\nfunction toSetString(aStr) {\r\n  if (isProtoString(aStr)) {\r\n    return \"$\" + aStr;\r\n  }\r\n\r\n  return aStr;\r\n}\r\nexports.toSetString = supportsNullProto ? identity : toSetString;\r\n\r\nfunction fromSetString(aStr) {\r\n  if (isProtoString(aStr)) {\r\n    return aStr.slice(1);\r\n  }\r\n\r\n  return aStr;\r\n}\r\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\r\n\r\nfunction isProtoString(s) {\r\n  if (!s) {\r\n    return false;\r\n  }\r\n\r\n  var length = s.length;\r\n\r\n  if (length < 9 /* \"__proto__\".length */) {\r\n    return false;\r\n  }\r\n\r\n  if (\r\n    s.charCodeAt(length - 1) !== 95 /* '_' */ ||\r\n    s.charCodeAt(length - 2) !== 95 /* '_' */ ||\r\n    s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\r\n    s.charCodeAt(length - 4) !== 116 /* 't' */ ||\r\n    s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\r\n    s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\r\n    s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\r\n    s.charCodeAt(length - 8) !== 95 /* '_' */ ||\r\n    s.charCodeAt(length - 9) !== 95 /* '_' */\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  for (var i = length - 10; i >= 0; i--) {\r\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Comparator between two mappings where the original positions are compared.\r\n *\r\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\r\n * mappings with the same original source/line/column, but different generated\r\n * line and column the same. Useful when searching for a mapping with a\r\n * stubbed out mapping.\r\n */\r\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\r\n  var cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0 || onlyCompareOriginal) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByOriginalPositions = compareByOriginalPositions;\r\n\r\n/**\r\n * Comparator between two mappings with deflated source and name indices where\r\n * the generated positions are compared.\r\n *\r\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\r\n * mappings with the same generated line and column, but different\r\n * source/name/original line and column the same. Useful when searching for a\r\n * mapping with a stubbed out mapping.\r\n */\r\nfunction compareByGeneratedPositionsDeflated(\r\n  mappingA,\r\n  mappingB,\r\n  onlyCompareGenerated\r\n) {\r\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0 || onlyCompareGenerated) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\r\n\r\nfunction strcmp(aStr1, aStr2) {\r\n  if (aStr1 === aStr2) {\r\n    return 0;\r\n  }\r\n\r\n  if (aStr1 === null) {\r\n    return 1; // aStr2 !== null\r\n  }\r\n\r\n  if (aStr2 === null) {\r\n    return -1; // aStr1 !== null\r\n  }\r\n\r\n  if (aStr1 > aStr2) {\r\n    return 1;\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\n/**\r\n * Comparator between two mappings with inflated source and name strings where\r\n * the generated positions are compared.\r\n */\r\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\r\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\r\n\r\n/**\r\n * Strip any JSON XSSI avoidance prefix from the string (as documented\r\n * in the source maps specification), and then parse the string as\r\n * JSON.\r\n */\r\nfunction parseSourceMapInput(str) {\r\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\r\n}\r\nexports.parseSourceMapInput = parseSourceMapInput;\r\n\r\n/**\r\n * Compute the URL of a source given the the source root, the source's\r\n * URL, and the source map's URL.\r\n */\r\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\r\n  sourceURL = sourceURL || \"\";\r\n\r\n  if (sourceRoot) {\r\n    // This follows what Chrome does.\r\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\r\n      sourceRoot += \"/\";\r\n    }\r\n    // The spec says:\r\n    //   Line 4: An optional source root, useful for relocating source\r\n    //   files on a server or removing repeated values in the\r\n    //   “sources” entry.  This value is prepended to the individual\r\n    //   entries in the “source” field.\r\n    sourceURL = sourceRoot + sourceURL;\r\n  }\r\n\r\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\r\n  // a parameter.  This mode is still somewhat supported, which is why\r\n  // this code block is conditional.  However, it's preferable to pass\r\n  // the source map URL to SourceMapConsumer, so that this function\r\n  // can implement the source URL resolution algorithm as outlined in\r\n  // the spec.  This block is basically the equivalent of:\r\n  //    new URL(sourceURL, sourceMapURL).toString()\r\n  // ... except it avoids using URL, which wasn't available in the\r\n  // older releases of node still supported by this library.\r\n  //\r\n  // The spec says:\r\n  //   If the sources are not absolute URLs after prepending of the\r\n  //   “sourceRoot”, the sources are resolved relative to the\r\n  //   SourceMap (like resolving script src in a html document).\r\n  if (sourceMapURL) {\r\n    var parsed = urlParse(sourceMapURL);\r\n    if (!parsed) {\r\n      throw new Error(\"sourceMapURL could not be parsed\");\r\n    }\r\n    if (parsed.path) {\r\n      // Strip the last path component, but keep the \"/\".\r\n      var index = parsed.path.lastIndexOf(\"/\");\r\n      if (index >= 0) {\r\n        parsed.path = parsed.path.substring(0, index + 1);\r\n      }\r\n    }\r\n    sourceURL = join(urlGenerate(parsed), sourceURL);\r\n  }\r\n\r\n  return normalize(sourceURL);\r\n}\r\nexports.computeSourceURL = computeSourceURL;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar base64VLQ = require(\"./base64-vlq\");\r\nvar util = require(\"./util\");\r\nvar ArraySet = require(\"./array-set\").ArraySet;\r\nvar MappingList = require(\"./mapping-list\").MappingList;\r\n\r\n/**\r\n * An instance of the SourceMapGenerator represents a source map which is\r\n * being built incrementally. You may pass an object with the following\r\n * properties:\r\n *\r\n *   - file: The filename of the generated source.\r\n *   - sourceRoot: A root for all relative URLs in this source map.\r\n */\r\nfunction SourceMapGenerator(aArgs) {\r\n  if (!aArgs) {\r\n    aArgs = {};\r\n  }\r\n  this._file = util.getArg(aArgs, \"file\", null);\r\n  this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\r\n  this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\r\n  this._sources = new ArraySet();\r\n  this._names = new ArraySet();\r\n  this._mappings = new MappingList();\r\n  this._sourcesContents = null;\r\n}\r\n\r\nSourceMapGenerator.prototype._version = 3;\r\n\r\n/**\r\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\r\n *\r\n * @param aSourceMapConsumer The SourceMap.\r\n */\r\nSourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(\r\n  aSourceMapConsumer\r\n) {\r\n  var sourceRoot = aSourceMapConsumer.sourceRoot;\r\n  var generator = new SourceMapGenerator({\r\n    file: aSourceMapConsumer.file,\r\n    sourceRoot: sourceRoot\r\n  });\r\n  aSourceMapConsumer.eachMapping(function(mapping) {\r\n    var newMapping = {\r\n      generated: {\r\n        line: mapping.generatedLine,\r\n        column: mapping.generatedColumn\r\n      }\r\n    };\r\n\r\n    if (mapping.source != null) {\r\n      newMapping.source = mapping.source;\r\n      if (sourceRoot != null) {\r\n        newMapping.source = util.relative(sourceRoot, newMapping.source);\r\n      }\r\n\r\n      newMapping.original = {\r\n        line: mapping.originalLine,\r\n        column: mapping.originalColumn\r\n      };\r\n\r\n      if (mapping.name != null) {\r\n        newMapping.name = mapping.name;\r\n      }\r\n    }\r\n\r\n    generator.addMapping(newMapping);\r\n  });\r\n  aSourceMapConsumer.sources.forEach(function(sourceFile) {\r\n    var sourceRelative = sourceFile;\r\n    if (sourceRoot !== null) {\r\n      sourceRelative = util.relative(sourceRoot, sourceFile);\r\n    }\r\n\r\n    if (!generator._sources.has(sourceRelative)) {\r\n      generator._sources.add(sourceRelative);\r\n    }\r\n\r\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n    if (content != null) {\r\n      generator.setSourceContent(sourceFile, content);\r\n    }\r\n  });\r\n  return generator;\r\n};\r\n\r\n/**\r\n * Add a single mapping from original source line and column to the generated\r\n * source's line and column for this source map being created. The mapping\r\n * object should have the following properties:\r\n *\r\n *   - generated: An object with the generated line and column positions.\r\n *   - original: An object with the original line and column positions.\r\n *   - source: The original source file (relative to the sourceRoot).\r\n *   - name: An optional original token name for this mapping.\r\n */\r\nSourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(\r\n  aArgs\r\n) {\r\n  var generated = util.getArg(aArgs, \"generated\");\r\n  var original = util.getArg(aArgs, \"original\", null);\r\n  var source = util.getArg(aArgs, \"source\", null);\r\n  var name = util.getArg(aArgs, \"name\", null);\r\n\r\n  if (!this._skipValidation) {\r\n    this._validateMapping(generated, original, source, name);\r\n  }\r\n\r\n  if (source != null) {\r\n    source = String(source);\r\n    if (!this._sources.has(source)) {\r\n      this._sources.add(source);\r\n    }\r\n  }\r\n\r\n  if (name != null) {\r\n    name = String(name);\r\n    if (!this._names.has(name)) {\r\n      this._names.add(name);\r\n    }\r\n  }\r\n\r\n  this._mappings.add({\r\n    generatedLine: generated.line,\r\n    generatedColumn: generated.column,\r\n    originalLine: original != null && original.line,\r\n    originalColumn: original != null && original.column,\r\n    source: source,\r\n    name: name\r\n  });\r\n};\r\n\r\n/**\r\n * Set the source content for a source file.\r\n */\r\nSourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(\r\n  aSourceFile,\r\n  aSourceContent\r\n) {\r\n  var source = aSourceFile;\r\n  if (this._sourceRoot != null) {\r\n    source = util.relative(this._sourceRoot, source);\r\n  }\r\n\r\n  if (aSourceContent != null) {\r\n    // Add the source content to the _sourcesContents map.\r\n    // Create a new _sourcesContents map if the property is null.\r\n    if (!this._sourcesContents) {\r\n      this._sourcesContents = Object.create(null);\r\n    }\r\n    this._sourcesContents[util.toSetString(source)] = aSourceContent;\r\n  } else if (this._sourcesContents) {\r\n    // Remove the source file from the _sourcesContents map.\r\n    // If the _sourcesContents map is empty, set the property to null.\r\n    delete this._sourcesContents[util.toSetString(source)];\r\n    if (Object.keys(this._sourcesContents).length === 0) {\r\n      this._sourcesContents = null;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Applies the mappings of a sub-source-map for a specific source file to the\r\n * source map being generated. Each mapping to the supplied source file is\r\n * rewritten using the supplied source map. Note: The resolution for the\r\n * resulting mappings is the minimium of this map and the supplied map.\r\n *\r\n * @param aSourceMapConsumer The source map to be applied.\r\n * @param aSourceFile Optional. The filename of the source file.\r\n *        If omitted, SourceMapConsumer's file property will be used.\r\n * @param aSourceMapPath Optional. The dirname of the path to the source map\r\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\r\n *        This parameter is needed when the two source maps aren't in the same\r\n *        directory, and the source map to be applied contains relative source\r\n *        paths. If so, those relative source paths need to be rewritten\r\n *        relative to the SourceMapGenerator.\r\n */\r\nSourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(\r\n  aSourceMapConsumer,\r\n  aSourceFile,\r\n  aSourceMapPath\r\n) {\r\n  var sourceFile = aSourceFile;\r\n  // If aSourceFile is omitted, we will use the file property of the SourceMap\r\n  if (aSourceFile == null) {\r\n    if (aSourceMapConsumer.file == null) {\r\n      throw new Error(\r\n        \"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" +\r\n          'or the source map\\'s \"file\" property. Both were omitted.'\r\n      );\r\n    }\r\n    sourceFile = aSourceMapConsumer.file;\r\n  }\r\n  var sourceRoot = this._sourceRoot;\r\n  // Make \"sourceFile\" relative if an absolute Url is passed.\r\n  if (sourceRoot != null) {\r\n    sourceFile = util.relative(sourceRoot, sourceFile);\r\n  }\r\n  // Applying the SourceMap can add and remove items from the sources and\r\n  // the names array.\r\n  var newSources =\r\n    this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;\r\n  var newNames = new ArraySet();\r\n\r\n  // Find mappings for the \"sourceFile\"\r\n  this._mappings.unsortedForEach(function(mapping) {\r\n    if (mapping.source === sourceFile && mapping.originalLine != null) {\r\n      // Check if it can be mapped by the source map, then update the mapping.\r\n      var original = aSourceMapConsumer.originalPositionFor({\r\n        line: mapping.originalLine,\r\n        column: mapping.originalColumn\r\n      });\r\n      if (original.source != null) {\r\n        // Copy mapping\r\n        mapping.source = original.source;\r\n        if (aSourceMapPath != null) {\r\n          mapping.source = util.join(aSourceMapPath, mapping.source);\r\n        }\r\n        if (sourceRoot != null) {\r\n          mapping.source = util.relative(sourceRoot, mapping.source);\r\n        }\r\n        mapping.originalLine = original.line;\r\n        mapping.originalColumn = original.column;\r\n        if (original.name != null) {\r\n          mapping.name = original.name;\r\n        }\r\n      }\r\n    }\r\n\r\n    var source = mapping.source;\r\n    if (source != null && !newSources.has(source)) {\r\n      newSources.add(source);\r\n    }\r\n\r\n    var name = mapping.name;\r\n    if (name != null && !newNames.has(name)) {\r\n      newNames.add(name);\r\n    }\r\n  }, this);\r\n  this._sources = newSources;\r\n  this._names = newNames;\r\n\r\n  // Copy sourcesContents of applied map.\r\n  aSourceMapConsumer.sources.forEach(function(sourceFile) {\r\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n    if (content != null) {\r\n      if (aSourceMapPath != null) {\r\n        sourceFile = util.join(aSourceMapPath, sourceFile);\r\n      }\r\n      if (sourceRoot != null) {\r\n        sourceFile = util.relative(sourceRoot, sourceFile);\r\n      }\r\n      this.setSourceContent(sourceFile, content);\r\n    }\r\n  }, this);\r\n};\r\n\r\n/**\r\n * A mapping can have one of the three levels of data:\r\n *\r\n *   1. Just the generated position.\r\n *   2. The Generated position, original position, and original source.\r\n *   3. Generated and original position, original source, as well as a name\r\n *      token.\r\n *\r\n * To maintain consistency, we validate that any new mapping being added falls\r\n * in to one of these categories.\r\n */\r\nSourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(\r\n  aGenerated,\r\n  aOriginal,\r\n  aSource,\r\n  aName\r\n) {\r\n  // When aOriginal is truthy but has empty values for .line and .column,\r\n  // it is most likely a programmer error. In this case we throw a very\r\n  // specific error message to try to guide them the right way.\r\n  // For example: https://github.com/Polymer/polymer-bundler/pull/519\r\n  if (\r\n    aOriginal &&\r\n    typeof aOriginal.line !== \"number\" &&\r\n    typeof aOriginal.column !== \"number\"\r\n  ) {\r\n    throw new Error(\r\n      \"original.line and original.column are not numbers -- you probably meant to omit \" +\r\n        \"the original mapping entirely and only map the generated position. If so, pass \" +\r\n        \"null for the original mapping instead of an object with empty or null values.\"\r\n    );\r\n  }\r\n\r\n  if (\r\n    aGenerated &&\r\n    \"line\" in aGenerated &&\r\n    \"column\" in aGenerated &&\r\n    aGenerated.line > 0 &&\r\n    aGenerated.column >= 0 &&\r\n    !aOriginal &&\r\n    !aSource &&\r\n    !aName\r\n  ) {\r\n    // Case 1.\r\n    return;\r\n  } else if (\r\n    aGenerated &&\r\n    \"line\" in aGenerated &&\r\n    \"column\" in aGenerated &&\r\n    aOriginal &&\r\n    \"line\" in aOriginal &&\r\n    \"column\" in aOriginal &&\r\n    aGenerated.line > 0 &&\r\n    aGenerated.column >= 0 &&\r\n    aOriginal.line > 0 &&\r\n    aOriginal.column >= 0 &&\r\n    aSource\r\n  ) {\r\n    // Cases 2 and 3.\r\n    return;\r\n  } else {\r\n    throw new Error(\r\n      \"Invalid mapping: \" +\r\n        JSON.stringify({\r\n          generated: aGenerated,\r\n          source: aSource,\r\n          original: aOriginal,\r\n          name: aName\r\n        })\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\r\n * specified by the source map format.\r\n */\r\nSourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\r\n  var previousGeneratedColumn = 0;\r\n  var previousGeneratedLine = 1;\r\n  var previousOriginalColumn = 0;\r\n  var previousOriginalLine = 0;\r\n  var previousName = 0;\r\n  var previousSource = 0;\r\n  var result = \"\";\r\n  var next;\r\n  var mapping;\r\n  var nameIdx;\r\n  var sourceIdx;\r\n\r\n  var mappings = this._mappings.toArray();\r\n  for (var i = 0, len = mappings.length; i < len; i++) {\r\n    mapping = mappings[i];\r\n    next = \"\";\r\n\r\n    if (mapping.generatedLine !== previousGeneratedLine) {\r\n      previousGeneratedColumn = 0;\r\n      while (mapping.generatedLine !== previousGeneratedLine) {\r\n        next += \";\";\r\n        previousGeneratedLine++;\r\n      }\r\n    } else {\r\n      if (i > 0) {\r\n        if (\r\n          !util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])\r\n        ) {\r\n          continue;\r\n        }\r\n        next += \",\";\r\n      }\r\n    }\r\n\r\n    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\r\n    previousGeneratedColumn = mapping.generatedColumn;\r\n\r\n    if (mapping.source != null) {\r\n      sourceIdx = this._sources.indexOf(mapping.source);\r\n      next += base64VLQ.encode(sourceIdx - previousSource);\r\n      previousSource = sourceIdx;\r\n\r\n      // lines are stored 0-based in SourceMap spec version 3\r\n      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\r\n      previousOriginalLine = mapping.originalLine - 1;\r\n\r\n      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\r\n      previousOriginalColumn = mapping.originalColumn;\r\n\r\n      if (mapping.name != null) {\r\n        nameIdx = this._names.indexOf(mapping.name);\r\n        next += base64VLQ.encode(nameIdx - previousName);\r\n        previousName = nameIdx;\r\n      }\r\n    }\r\n\r\n    result += next;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\nSourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(\r\n  aSources,\r\n  aSourceRoot\r\n) {\r\n  return aSources.map(function(source) {\r\n    if (!this._sourcesContents) {\r\n      return null;\r\n    }\r\n    if (aSourceRoot != null) {\r\n      source = util.relative(aSourceRoot, source);\r\n    }\r\n    var key = util.toSetString(source);\r\n    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\r\n      ? this._sourcesContents[key]\r\n      : null;\r\n  }, this);\r\n};\r\n\r\n/**\r\n * Externalize the source map.\r\n */\r\nSourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\r\n  var map = {\r\n    version: this._version,\r\n    sources: this._sources.toArray(),\r\n    names: this._names.toArray(),\r\n    mappings: this._serializeMappings()\r\n  };\r\n  if (this._file != null) {\r\n    map.file = this._file;\r\n  }\r\n  if (this._sourceRoot != null) {\r\n    map.sourceRoot = this._sourceRoot;\r\n  }\r\n  if (this._sourcesContents) {\r\n    map.sourcesContent = this._generateSourcesContent(\r\n      map.sources,\r\n      map.sourceRoot\r\n    );\r\n  }\r\n\r\n  return map;\r\n};\r\n\r\n/**\r\n * Render the source map being generated to a string.\r\n */\r\nSourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\r\n  return JSON.stringify(this.toJSON());\r\n};\r\n\r\nexports.SourceMapGenerator = SourceMapGenerator;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n *\r\n * Based on the Base 64 VLQ implementation in Closure Compiler:\r\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\r\n *\r\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *  * Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above\r\n *    copyright notice, this list of conditions and the following\r\n *    disclaimer in the documentation and/or other materials provided\r\n *    with the distribution.\r\n *  * Neither the name of Google Inc. nor the names of its\r\n *    contributors may be used to endorse or promote products derived\r\n *    from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar base64 = require(\"./base64\");\r\n\r\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\r\n// length quantities we use in the source map spec, the first bit is the sign,\r\n// the next four bits are the actual value, and the 6th bit is the\r\n// continuation bit. The continuation bit tells us whether there are more\r\n// digits in this value following this digit.\r\n//\r\n//   Continuation\r\n//   |    Sign\r\n//   |    |\r\n//   V    V\r\n//   101011\r\n\r\nvar VLQ_BASE_SHIFT = 5;\r\n\r\n// binary: 100000\r\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\r\n\r\n// binary: 011111\r\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\r\n\r\n// binary: 100000\r\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\r\n\r\n/**\r\n * Converts from a two-complement value to a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\r\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\r\n */\r\nfunction toVLQSigned(aValue) {\r\n  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\r\n}\r\n\r\n/**\r\n * Converts to a two-complement value from a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\r\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\r\n */\r\nfunction fromVLQSigned(aValue) {\r\n  var isNegative = (aValue & 1) === 1;\r\n  var shifted = aValue >> 1;\r\n  return isNegative ? -shifted : shifted;\r\n}\r\n\r\n/**\r\n * Returns the base 64 VLQ encoded value.\r\n */\r\nexports.encode = function base64VLQ_encode(aValue) {\r\n  var encoded = \"\";\r\n  var digit;\r\n\r\n  var vlq = toVLQSigned(aValue);\r\n\r\n  do {\r\n    digit = vlq & VLQ_BASE_MASK;\r\n    vlq >>>= VLQ_BASE_SHIFT;\r\n    if (vlq > 0) {\r\n      // There are still more digits in this value, so we must make sure the\r\n      // continuation bit is marked.\r\n      digit |= VLQ_CONTINUATION_BIT;\r\n    }\r\n    encoded += base64.encode(digit);\r\n  } while (vlq > 0);\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n * Decodes the next base 64 VLQ value from the given string and returns the\r\n * value and the rest of the string via the out parameter.\r\n */\r\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\r\n  var strLen = aStr.length;\r\n  var result = 0;\r\n  var shift = 0;\r\n  var continuation, digit;\r\n\r\n  do {\r\n    if (aIndex >= strLen) {\r\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\r\n    }\r\n\r\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\r\n    if (digit === -1) {\r\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\r\n    }\r\n\r\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\r\n    digit &= VLQ_BASE_MASK;\r\n    result = result + (digit << shift);\r\n    shift += VLQ_BASE_SHIFT;\r\n  } while (continuation);\r\n\r\n  aOutParam.value = fromVLQSigned(result);\r\n  aOutParam.rest = aIndex;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require(\"./util\");\r\nvar has = Object.prototype.hasOwnProperty;\r\nvar hasNativeMap = typeof Map !== \"undefined\";\r\n\r\n/**\r\n * A data structure which is a combination of an array and a set. Adding a new\r\n * member is O(1), testing for membership is O(1), and finding the index of an\r\n * element is O(1). Removing elements from the set is not supported. Only\r\n * strings are supported for membership.\r\n */\r\nfunction ArraySet() {\r\n  this._array = [];\r\n  this._set = hasNativeMap ? new Map() : Object.create(null);\r\n}\r\n\r\n/**\r\n * Static method for creating ArraySet instances from an existing array.\r\n */\r\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\r\n  var set = new ArraySet();\r\n  for (var i = 0, len = aArray.length; i < len; i++) {\r\n    set.add(aArray[i], aAllowDuplicates);\r\n  }\r\n  return set;\r\n};\r\n\r\n/**\r\n * Return how many unique items are in this ArraySet. If duplicates have been\r\n * added, than those do not count towards the size.\r\n *\r\n * @returns Number\r\n */\r\nArraySet.prototype.size = function ArraySet_size() {\r\n  return hasNativeMap\r\n    ? this._set.size\r\n    : Object.getOwnPropertyNames(this._set).length;\r\n};\r\n\r\n/**\r\n * Add the given string to this set.\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\r\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\r\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\r\n  var idx = this._array.length;\r\n  if (!isDuplicate || aAllowDuplicates) {\r\n    this._array.push(aStr);\r\n  }\r\n  if (!isDuplicate) {\r\n    if (hasNativeMap) {\r\n      this._set.set(aStr, idx);\r\n    } else {\r\n      this._set[sStr] = idx;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Is the given string a member of this set?\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.has = function ArraySet_has(aStr) {\r\n  if (hasNativeMap) {\r\n    return this._set.has(aStr);\r\n  } else {\r\n    var sStr = util.toSetString(aStr);\r\n    return has.call(this._set, sStr);\r\n  }\r\n};\r\n\r\n/**\r\n * What is the index of the given string in the array?\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\r\n  if (hasNativeMap) {\r\n    var idx = this._set.get(aStr);\r\n    if (idx >= 0) {\r\n      return idx;\r\n    }\r\n  } else {\r\n    var sStr = util.toSetString(aStr);\r\n    if (has.call(this._set, sStr)) {\r\n      return this._set[sStr];\r\n    }\r\n  }\r\n\r\n  throw new Error('\"' + aStr + '\" is not in the set.');\r\n};\r\n\r\n/**\r\n * What is the element at the given index?\r\n *\r\n * @param Number aIdx\r\n */\r\nArraySet.prototype.at = function ArraySet_at(aIdx) {\r\n  if (aIdx >= 0 && aIdx < this._array.length) {\r\n    return this._array[aIdx];\r\n  }\r\n  throw new Error(\"No element indexed by \" + aIdx);\r\n};\r\n\r\n/**\r\n * Returns the array representation of this set (which has the proper indices\r\n * indicated by indexOf). Note that this is a copy of the internal array used\r\n * for storing the members so that no one can mess with internal state.\r\n */\r\nArraySet.prototype.toArray = function ArraySet_toArray() {\r\n  return this._array.slice();\r\n};\r\n\r\nexports.ArraySet = ArraySet;\r\n","/*\r\n * Copyright 2009-2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE.txt or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\nexports.SourceMapGenerator = require(\"./lib/source-map-generator\").SourceMapGenerator;\r\nexports.SourceMapConsumer = require(\"./lib/source-map-consumer\").SourceMapConsumer;\r\nexports.SourceNode = require(\"./lib/source-node\").SourceNode;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\r\n  \"\"\r\n);\r\n\r\n/**\r\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\r\n */\r\nexports.encode = function(number) {\r\n  if (0 <= number && number < intToCharMap.length) {\r\n    return intToCharMap[number];\r\n  }\r\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\r\n};\r\n\r\n/**\r\n * Decode a single base 64 character code digit to an integer. Returns -1 on\r\n * failure.\r\n */\r\nexports.decode = function(charCode) {\r\n  var bigA = 65; // 'A'\r\n  var bigZ = 90; // 'Z'\r\n\r\n  var littleA = 97; // 'a'\r\n  var littleZ = 122; // 'z'\r\n\r\n  var zero = 48; // '0'\r\n  var nine = 57; // '9'\r\n\r\n  var plus = 43; // '+'\r\n  var slash = 47; // '/'\r\n\r\n  var littleOffset = 26;\r\n  var numberOffset = 52;\r\n\r\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n  if (bigA <= charCode && charCode <= bigZ) {\r\n    return charCode - bigA;\r\n  }\r\n\r\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\r\n  if (littleA <= charCode && charCode <= littleZ) {\r\n    return charCode - littleA + littleOffset;\r\n  }\r\n\r\n  // 52 - 61: 0123456789\r\n  if (zero <= charCode && charCode <= nine) {\r\n    return charCode - zero + numberOffset;\r\n  }\r\n\r\n  // 62: +\r\n  if (charCode == plus) {\r\n    return 62;\r\n  }\r\n\r\n  // 63: /\r\n  if (charCode == slash) {\r\n    return 63;\r\n  }\r\n\r\n  // Invalid base64 digit.\r\n  return -1;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2014 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require(\"./util\");\r\n\r\n/**\r\n * Determine whether mappingB is after mappingA with respect to generated\r\n * position.\r\n */\r\nfunction generatedPositionAfter(mappingA, mappingB) {\r\n  // Optimized for most common case\r\n  var lineA = mappingA.generatedLine;\r\n  var lineB = mappingB.generatedLine;\r\n  var columnA = mappingA.generatedColumn;\r\n  var columnB = mappingB.generatedColumn;\r\n  return (\r\n    lineB > lineA ||\r\n    (lineB == lineA && columnB >= columnA) ||\r\n    util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0\r\n  );\r\n}\r\n\r\n/**\r\n * A data structure to provide a sorted view of accumulated mappings in a\r\n * performance conscious manner. It trades a negligible overhead in general\r\n * case for a large speedup in case of mappings being added in order.\r\n */\r\nfunction MappingList() {\r\n  this._array = [];\r\n  this._sorted = true;\r\n  // Serves as infimum\r\n  this._last = { generatedLine: -1, generatedColumn: 0 };\r\n}\r\n\r\n/**\r\n * Iterate through internal items. This method takes the same arguments that\r\n * `Array.prototype.forEach` takes.\r\n *\r\n * NOTE: The order of the mappings is NOT guaranteed.\r\n */\r\nMappingList.prototype.unsortedForEach = function MappingList_forEach(\r\n  aCallback,\r\n  aThisArg\r\n) {\r\n  this._array.forEach(aCallback, aThisArg);\r\n};\r\n\r\n/**\r\n * Add the given source mapping.\r\n *\r\n * @param Object aMapping\r\n */\r\nMappingList.prototype.add = function MappingList_add(aMapping) {\r\n  if (generatedPositionAfter(this._last, aMapping)) {\r\n    this._last = aMapping;\r\n    this._array.push(aMapping);\r\n  } else {\r\n    this._sorted = false;\r\n    this._array.push(aMapping);\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the flat, sorted array of mappings. The mappings are sorted by\r\n * generated position.\r\n *\r\n * WARNING: This method returns internal data without copying, for\r\n * performance. The return value must NOT be mutated, and should be treated as\r\n * an immutable borrow. If you want to take ownership, you must make your own\r\n * copy.\r\n */\r\nMappingList.prototype.toArray = function MappingList_toArray() {\r\n  if (!this._sorted) {\r\n    this._array.sort(util.compareByGeneratedPositionsInflated);\r\n    this._sorted = true;\r\n  }\r\n  return this._array;\r\n};\r\n\r\nexports.MappingList = MappingList;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require(\"./util\");\r\nvar binarySearch = require(\"./binary-search\");\r\nvar ArraySet = require(\"./array-set\").ArraySet;\r\nvar base64VLQ = require(\"./base64-vlq\");\r\nvar quickSort = require(\"./quick-sort\").quickSort;\r\n\r\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === \"string\") {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  return sourceMap.sections != null\r\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\r\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\r\n}\r\n\r\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\r\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\r\n};\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nSourceMapConsumer.prototype._version = 3;\r\n\r\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\r\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\r\n// are lazily instantiated, accessed via the `_generatedMappings` and\r\n// `_originalMappings` getters respectively, and we only parse the mappings\r\n// and create these arrays once queried for a source location. We jump through\r\n// these hoops because there can be many thousands of mappings, and parsing\r\n// them is expensive, so we only want to do it if we must.\r\n//\r\n// Each object in the arrays is of the form:\r\n//\r\n//     {\r\n//       generatedLine: The line number in the generated code,\r\n//       generatedColumn: The column number in the generated code,\r\n//       source: The path to the original source file that generated this\r\n//               chunk of code,\r\n//       originalLine: The line number in the original source that\r\n//                     corresponds to this chunk of generated code,\r\n//       originalColumn: The column number in the original source that\r\n//                       corresponds to this chunk of generated code,\r\n//       name: The name of the original symbol which generated this chunk of\r\n//             code.\r\n//     }\r\n//\r\n// All properties except for `generatedLine` and `generatedColumn` can be\r\n// `null`.\r\n//\r\n// `_generatedMappings` is ordered by the generated positions.\r\n//\r\n// `_originalMappings` is ordered by the original positions.\r\n\r\nSourceMapConsumer.prototype.__generatedMappings = null;\r\nObject.defineProperty(SourceMapConsumer.prototype, \"_generatedMappings\", {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get: function() {\r\n    if (!this.__generatedMappings) {\r\n      this._sortGeneratedMappings();\r\n    }\r\n\r\n    return this.__generatedMappings;\r\n  }\r\n});\r\n\r\nSourceMapConsumer.prototype.__originalMappings = null;\r\nObject.defineProperty(SourceMapConsumer.prototype, \"_originalMappings\", {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get: function() {\r\n    if (!this.__originalMappings) {\r\n      this._sortOriginalMappings();\r\n    }\r\n\r\n    return this.__originalMappings;\r\n  }\r\n});\r\n\r\nSourceMapConsumer.prototype.__generatedMappingsUnsorted = null;\r\nObject.defineProperty(\r\n  SourceMapConsumer.prototype,\r\n  \"_generatedMappingsUnsorted\",\r\n  {\r\n    configurable: true,\r\n    enumerable: true,\r\n    get: function() {\r\n      if (!this.__generatedMappingsUnsorted) {\r\n        this._parseMappings(this._mappings, this.sourceRoot);\r\n      }\r\n\r\n      return this.__generatedMappingsUnsorted;\r\n    }\r\n  }\r\n);\r\n\r\nSourceMapConsumer.prototype.__originalMappingsUnsorted = null;\r\nObject.defineProperty(\r\n  SourceMapConsumer.prototype,\r\n  \"_originalMappingsUnsorted\",\r\n  {\r\n    configurable: true,\r\n    enumerable: true,\r\n    get: function() {\r\n      if (!this.__originalMappingsUnsorted) {\r\n        this._parseMappings(this._mappings, this.sourceRoot);\r\n      }\r\n\r\n      return this.__originalMappingsUnsorted;\r\n    }\r\n  }\r\n);\r\n\r\nSourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(\r\n  aStr,\r\n  index\r\n) {\r\n  var c = aStr.charAt(index);\r\n  return c === \";\" || c === \",\";\r\n};\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(\r\n  aStr,\r\n  aSourceRoot\r\n) {\r\n  throw new Error(\"Subclasses must implement _parseMappings\");\r\n};\r\n\r\nSourceMapConsumer.prototype._sortGeneratedMappings = function SourceMapConsumer_sortGeneratedMappings() {\r\n  const mappings = this._generatedMappingsUnsorted;\r\n  quickSort(mappings, util.compareByGeneratedPositionsDeflated);\r\n  this.__generatedMappings = mappings;\r\n};\r\n\r\nSourceMapConsumer.prototype._sortOriginalMappings = function SourceMapConsumer_sortOriginalMappings() {\r\n  const mappings = this._originalMappingsUnsorted;\r\n  quickSort(mappings, util.compareByOriginalPositions);\r\n  this.__originalMappings = mappings;\r\n};\r\n\r\nSourceMapConsumer.GENERATED_ORDER = 1;\r\nSourceMapConsumer.ORIGINAL_ORDER = 2;\r\n\r\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\r\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\r\n\r\n/**\r\n * Iterate over each mapping between an original source/line/column and a\r\n * generated line/column in this source map.\r\n *\r\n * @param Function aCallback\r\n *        The function that is called with each mapping.\r\n * @param Object aContext\r\n *        Optional. If specified, this object will be the value of `this` every\r\n *        time that `aCallback` is called.\r\n * @param aOrder\r\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\r\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\r\n *        iterate over the mappings sorted by the generated file's line/column\r\n *        order or the original's source/line/column order, respectively. Defaults to\r\n *        `SourceMapConsumer.GENERATED_ORDER`.\r\n */\r\nSourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(\r\n  aCallback,\r\n  aContext,\r\n  aOrder\r\n) {\r\n  var context = aContext || null;\r\n  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\r\n\r\n  var mappings;\r\n  switch (order) {\r\n    case SourceMapConsumer.GENERATED_ORDER:\r\n      mappings = this._generatedMappings;\r\n      break;\r\n    case SourceMapConsumer.ORIGINAL_ORDER:\r\n      mappings = this._originalMappings;\r\n      break;\r\n    default:\r\n      throw new Error(\"Unknown order of iteration.\");\r\n  }\r\n\r\n  var sourceRoot = this.sourceRoot;\r\n  mappings\r\n    .map(function(mapping) {\r\n      var source = null;\r\n      if (mapping.source != null) {\r\n        source = this._sources.at(mapping.source);\r\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\r\n      }\r\n      return {\r\n        source: source,\r\n        generatedLine: mapping.generatedLine,\r\n        generatedColumn: mapping.generatedColumn,\r\n        originalLine: mapping.originalLine,\r\n        originalColumn: mapping.originalColumn,\r\n        name: mapping.name == null ? null : this._names.at(mapping.name)\r\n      };\r\n    }, this)\r\n    .forEach(aCallback, context);\r\n};\r\n\r\n/**\r\n * Returns all generated line and column information for the original source,\r\n * line, and column provided. If no column is provided, returns all mappings\r\n * corresponding to a either the line we are searching for or the next\r\n * closest line that has any mappings. Otherwise, returns all mappings\r\n * corresponding to the given line and either the column we are searching for\r\n * or the next closest column that has any offsets.\r\n *\r\n * The only argument is an object with the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number is 1-based.\r\n *   - column: Optional. the column number in the original source.\r\n *    The column number is 0-based.\r\n *\r\n * and an array of objects is returned, each with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *    line number is 1-based.\r\n *   - column: The column number in the generated source, or null.\r\n *    The column number is 0-based.\r\n */\r\nSourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(\r\n  aArgs\r\n) {\r\n  var line = util.getArg(aArgs, \"line\");\r\n\r\n  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\r\n  // returns the index of the closest mapping less than the needle. By\r\n  // setting needle.originalColumn to 0, we thus find the last mapping for\r\n  // the given line, provided such a mapping exists.\r\n  var needle = {\r\n    source: util.getArg(aArgs, \"source\"),\r\n    originalLine: line,\r\n    originalColumn: util.getArg(aArgs, \"column\", 0)\r\n  };\r\n\r\n  needle.source = this._findSourceIndex(needle.source);\r\n  if (needle.source < 0) {\r\n    return [];\r\n  }\r\n\r\n  var mappings = [];\r\n\r\n  var index = this._findMapping(\r\n    needle,\r\n    this._originalMappings,\r\n    \"originalLine\",\r\n    \"originalColumn\",\r\n    util.compareByOriginalPositions,\r\n    binarySearch.LEAST_UPPER_BOUND\r\n  );\r\n  if (index >= 0) {\r\n    var mapping = this._originalMappings[index];\r\n\r\n    if (aArgs.column === undefined) {\r\n      var originalLine = mapping.originalLine;\r\n\r\n      // Iterate until either we run out of mappings, or we run into\r\n      // a mapping for a different line than the one we found. Since\r\n      // mappings are sorted, this is guaranteed to find all mappings for\r\n      // the line we found.\r\n      while (mapping && mapping.originalLine === originalLine) {\r\n        mappings.push({\r\n          line: util.getArg(mapping, \"generatedLine\", null),\r\n          column: util.getArg(mapping, \"generatedColumn\", null),\r\n          lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\r\n        });\r\n\r\n        mapping = this._originalMappings[++index];\r\n      }\r\n    } else {\r\n      var originalColumn = mapping.originalColumn;\r\n\r\n      // Iterate until either we run out of mappings, or we run into\r\n      // a mapping for a different line than the one we were searching for.\r\n      // Since mappings are sorted, this is guaranteed to find all mappings for\r\n      // the line we are searching for.\r\n      while (\r\n        mapping &&\r\n        mapping.originalLine === line &&\r\n        mapping.originalColumn == originalColumn\r\n      ) {\r\n        mappings.push({\r\n          line: util.getArg(mapping, \"generatedLine\", null),\r\n          column: util.getArg(mapping, \"generatedColumn\", null),\r\n          lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\r\n        });\r\n\r\n        mapping = this._originalMappings[++index];\r\n      }\r\n    }\r\n  }\r\n\r\n  return mappings;\r\n};\r\n\r\nexports.SourceMapConsumer = SourceMapConsumer;\r\n\r\n/**\r\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\r\n * query for information about the original file positions by giving it a file\r\n * position in the generated source.\r\n *\r\n * The first parameter is the raw source map (either as a JSON string, or\r\n * already parsed to an object). According to the spec, source maps have the\r\n * following attributes:\r\n *\r\n *   - version: Which version of the source map spec this map is following.\r\n *   - sources: An array of URLs to the original source files.\r\n *   - names: An array of identifiers which can be referenced by individual mappings.\r\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\r\n *   - sourcesContent: Optional. An array of contents of the original source files.\r\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\r\n *   - file: Optional. The generated file this source map is associated with.\r\n *\r\n * Here is an example source map, taken from the source map spec[0]:\r\n *\r\n *     {\r\n *       version : 3,\r\n *       file: \"out.js\",\r\n *       sourceRoot : \"\",\r\n *       sources: [\"foo.js\", \"bar.js\"],\r\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\r\n *       mappings: \"AA,AB;;ABCDE;\"\r\n *     }\r\n *\r\n * The second parameter, if given, is a string whose value is the URL\r\n * at which the source map was found.  This URL is used to compute the\r\n * sources array.\r\n *\r\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\r\n */\r\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === \"string\") {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  var version = util.getArg(sourceMap, \"version\");\r\n  var sources = util.getArg(sourceMap, \"sources\");\r\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\r\n  // requires the array) to play nice here.\r\n  var names = util.getArg(sourceMap, \"names\", []);\r\n  var sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\r\n  var sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\r\n  var mappings = util.getArg(sourceMap, \"mappings\");\r\n  var file = util.getArg(sourceMap, \"file\", null);\r\n\r\n  // Once again, Sass deviates from the spec and supplies the version as a\r\n  // string rather than a number, so we use loose equality checking here.\r\n  if (version != this._version) {\r\n    throw new Error(\"Unsupported version: \" + version);\r\n  }\r\n\r\n  if (sourceRoot) {\r\n    sourceRoot = util.normalize(sourceRoot);\r\n  }\r\n\r\n  sources = sources\r\n    .map(String)\r\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\r\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\r\n    // See bugzil.la/1090768.\r\n    .map(util.normalize)\r\n    // Always ensure that absolute sources are internally stored relative to\r\n    // the source root, if the source root is absolute. Not doing this would\r\n    // be particularly problematic when the source root is a prefix of the\r\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\r\n    .map(function(source) {\r\n      return sourceRoot &&\r\n        util.isAbsolute(sourceRoot) &&\r\n        util.isAbsolute(source)\r\n        ? util.relative(sourceRoot, source)\r\n        : source;\r\n    });\r\n\r\n  // Pass `true` below to allow duplicate names and sources. While source maps\r\n  // are intended to be compressed and deduplicated, the TypeScript compiler\r\n  // sometimes generates source maps with duplicates in them. See Github issue\r\n  // #72 and bugzil.la/889492.\r\n  this._names = ArraySet.fromArray(names.map(String), true);\r\n  this._sources = ArraySet.fromArray(sources, true);\r\n\r\n  this._absoluteSources = this._sources.toArray().map(function(s) {\r\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\r\n  });\r\n\r\n  this.sourceRoot = sourceRoot;\r\n  this.sourcesContent = sourcesContent;\r\n  this._mappings = mappings;\r\n  this._sourceMapURL = aSourceMapURL;\r\n  this.file = file;\r\n}\r\n\r\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\r\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\r\n\r\n/**\r\n * Utility function to find the index of a source.  Returns -1 if not\r\n * found.\r\n */\r\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\r\n  var relativeSource = aSource;\r\n  if (this.sourceRoot != null) {\r\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\r\n  }\r\n\r\n  if (this._sources.has(relativeSource)) {\r\n    return this._sources.indexOf(relativeSource);\r\n  }\r\n\r\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\r\n  // this case we can't simply undo the transform.\r\n  var i;\r\n  for (i = 0; i < this._absoluteSources.length; ++i) {\r\n    if (this._absoluteSources[i] == aSource) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n};\r\n\r\n/**\r\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\r\n *\r\n * @param SourceMapGenerator aSourceMap\r\n *        The source map that will be consumed.\r\n * @param String aSourceMapURL\r\n *        The URL at which the source map can be found (optional)\r\n * @returns BasicSourceMapConsumer\r\n */\r\nBasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(\r\n  aSourceMap,\r\n  aSourceMapURL\r\n) {\r\n  var smc = Object.create(BasicSourceMapConsumer.prototype);\r\n\r\n  var names = (smc._names = ArraySet.fromArray(\r\n    aSourceMap._names.toArray(),\r\n    true\r\n  ));\r\n  var sources = (smc._sources = ArraySet.fromArray(\r\n    aSourceMap._sources.toArray(),\r\n    true\r\n  ));\r\n  smc.sourceRoot = aSourceMap._sourceRoot;\r\n  smc.sourcesContent = aSourceMap._generateSourcesContent(\r\n    smc._sources.toArray(),\r\n    smc.sourceRoot\r\n  );\r\n  smc.file = aSourceMap._file;\r\n  smc._sourceMapURL = aSourceMapURL;\r\n  smc._absoluteSources = smc._sources.toArray().map(function(s) {\r\n    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\r\n  });\r\n\r\n  // Because we are modifying the entries (by converting string sources and\r\n  // names to indices into the sources and names ArraySets), we have to make\r\n  // a copy of the entry or else bad things happen. Shared mutable state\r\n  // strikes again! See github issue #191.\r\n\r\n  var generatedMappings = aSourceMap._mappings.toArray().slice();\r\n  var destGeneratedMappings = (smc.__generatedMappings = []);\r\n  var destOriginalMappings = (smc.__originalMappings = []);\r\n\r\n  for (var i = 0, length = generatedMappings.length; i < length; i++) {\r\n    var srcMapping = generatedMappings[i];\r\n    var destMapping = new Mapping();\r\n    destMapping.generatedLine = srcMapping.generatedLine;\r\n    destMapping.generatedColumn = srcMapping.generatedColumn;\r\n\r\n    if (srcMapping.source) {\r\n      destMapping.source = sources.indexOf(srcMapping.source);\r\n      destMapping.originalLine = srcMapping.originalLine;\r\n      destMapping.originalColumn = srcMapping.originalColumn;\r\n\r\n      if (srcMapping.name) {\r\n        destMapping.name = names.indexOf(srcMapping.name);\r\n      }\r\n\r\n      destOriginalMappings.push(destMapping);\r\n    }\r\n\r\n    destGeneratedMappings.push(destMapping);\r\n  }\r\n\r\n  quickSort(smc.__originalMappings, util.compareByOriginalPositions);\r\n\r\n  return smc;\r\n};\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nBasicSourceMapConsumer.prototype._version = 3;\r\n\r\n/**\r\n * The list of original sources.\r\n */\r\nObject.defineProperty(BasicSourceMapConsumer.prototype, \"sources\", {\r\n  get: function() {\r\n    return this._absoluteSources.slice();\r\n  }\r\n});\r\n\r\n/**\r\n * Provide the JIT with a nice shape / hidden class.\r\n */\r\nfunction Mapping() {\r\n  this.generatedLine = 0;\r\n  this.generatedColumn = 0;\r\n  this.source = null;\r\n  this.originalLine = null;\r\n  this.originalColumn = null;\r\n  this.name = null;\r\n}\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nBasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(\r\n  aStr,\r\n  aSourceRoot\r\n) {\r\n  var generatedLine = 1;\r\n  var previousGeneratedColumn = 0;\r\n  var previousOriginalLine = 0;\r\n  var previousOriginalColumn = 0;\r\n  var previousSource = 0;\r\n  var previousName = 0;\r\n  var length = aStr.length;\r\n  var index = 0;\r\n  var cachedSegments = {};\r\n  var temp = {};\r\n  var originalMappings = [];\r\n  var generatedMappings = [];\r\n  var mapping, str, segment, end, value;\r\n\r\n  while (index < length) {\r\n    if (aStr.charAt(index) === \";\") {\r\n      generatedLine++;\r\n      index++;\r\n      previousGeneratedColumn = 0;\r\n    } else if (aStr.charAt(index) === \",\") {\r\n      index++;\r\n    } else {\r\n      mapping = new Mapping();\r\n      mapping.generatedLine = generatedLine;\r\n\r\n      // Because each offset is encoded relative to the previous one,\r\n      // many segments often have the same encoding. We can exploit this\r\n      // fact by caching the parsed variable length fields of each segment,\r\n      // allowing us to avoid a second parse if we encounter the same\r\n      // segment again.\r\n      for (end = index; end < length; end++) {\r\n        if (this._charIsMappingSeparator(aStr, end)) {\r\n          break;\r\n        }\r\n      }\r\n      str = aStr.slice(index, end);\r\n\r\n      segment = cachedSegments[str];\r\n      if (segment) {\r\n        index += str.length;\r\n      } else {\r\n        segment = [];\r\n        while (index < end) {\r\n          base64VLQ.decode(aStr, index, temp);\r\n          value = temp.value;\r\n          index = temp.rest;\r\n          segment.push(value);\r\n        }\r\n\r\n        if (segment.length === 2) {\r\n          throw new Error(\"Found a source, but no line and column\");\r\n        }\r\n\r\n        if (segment.length === 3) {\r\n          throw new Error(\"Found a source and line, but no column\");\r\n        }\r\n\r\n        cachedSegments[str] = segment;\r\n      }\r\n\r\n      // Generated column.\r\n      mapping.generatedColumn = previousGeneratedColumn + segment[0];\r\n      previousGeneratedColumn = mapping.generatedColumn;\r\n\r\n      if (segment.length > 1) {\r\n        // Original source.\r\n        mapping.source = previousSource + segment[1];\r\n        previousSource += segment[1];\r\n\r\n        // Original line.\r\n        mapping.originalLine = previousOriginalLine + segment[2];\r\n        previousOriginalLine = mapping.originalLine;\r\n        // Lines are stored 0-based\r\n        mapping.originalLine += 1;\r\n\r\n        // Original column.\r\n        mapping.originalColumn = previousOriginalColumn + segment[3];\r\n        previousOriginalColumn = mapping.originalColumn;\r\n\r\n        if (segment.length > 4) {\r\n          // Original name.\r\n          mapping.name = previousName + segment[4];\r\n          previousName += segment[4];\r\n        }\r\n      }\r\n\r\n      generatedMappings.push(mapping);\r\n      if (typeof mapping.originalLine === \"number\") {\r\n        originalMappings.push(mapping);\r\n      }\r\n    }\r\n  }\r\n\r\n  this.__generatedMappingsUnsorted = generatedMappings;\r\n\r\n  this.__originalMappingsUnsorted = originalMappings;\r\n};\r\n\r\n/**\r\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\r\n * we are searching for in the given \"haystack\" of mappings.\r\n */\r\nBasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(\r\n  aNeedle,\r\n  aMappings,\r\n  aLineName,\r\n  aColumnName,\r\n  aComparator,\r\n  aBias\r\n) {\r\n  // To return the position we are searching for, we must first find the\r\n  // mapping for the given position and then return the opposite position it\r\n  // points to. Because the mappings are sorted, we can use binary search to\r\n  // find the best mapping.\r\n\r\n  if (aNeedle[aLineName] <= 0) {\r\n    throw new TypeError(\r\n      \"Line must be greater than or equal to 1, got \" + aNeedle[aLineName]\r\n    );\r\n  }\r\n  if (aNeedle[aColumnName] < 0) {\r\n    throw new TypeError(\r\n      \"Column must be greater than or equal to 0, got \" + aNeedle[aColumnName]\r\n    );\r\n  }\r\n\r\n  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\r\n};\r\n\r\n/**\r\n * Compute the last column for each generated mapping. The last column is\r\n * inclusive.\r\n */\r\nBasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\r\n  for (var index = 0; index < this._generatedMappings.length; ++index) {\r\n    var mapping = this._generatedMappings[index];\r\n\r\n    // Mappings do not contain a field for the last generated columnt. We\r\n    // can come up with an optimistic estimate, however, by assuming that\r\n    // mappings are contiguous (i.e. given two consecutive mappings, the\r\n    // first mapping ends where the second one starts).\r\n    if (index + 1 < this._generatedMappings.length) {\r\n      var nextMapping = this._generatedMappings[index + 1];\r\n\r\n      if (mapping.generatedLine === nextMapping.generatedLine) {\r\n        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // The last mapping for each line spans the entire line.\r\n    mapping.lastGeneratedColumn = Infinity;\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the original source, line, and column information for the generated\r\n * source's line and column positions provided. The only argument is an object\r\n * with the following properties:\r\n *\r\n *   - line: The line number in the generated source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the generated source.  The column\r\n *     number is 0-based.\r\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\r\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - source: The original source file, or null.\r\n *   - line: The line number in the original source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the original source, or null.  The\r\n *     column number is 0-based.\r\n *   - name: The original identifier, or null.\r\n */\r\nBasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(\r\n  aArgs\r\n) {\r\n  var needle = {\r\n    generatedLine: util.getArg(aArgs, \"line\"),\r\n    generatedColumn: util.getArg(aArgs, \"column\")\r\n  };\r\n\r\n  var index = this._findMapping(\r\n    needle,\r\n    this._generatedMappings,\r\n    \"generatedLine\",\r\n    \"generatedColumn\",\r\n    util.compareByGeneratedPositionsDeflated,\r\n    util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND)\r\n  );\r\n\r\n  if (index >= 0) {\r\n    var mapping = this._generatedMappings[index];\r\n\r\n    if (mapping.generatedLine === needle.generatedLine) {\r\n      var source = util.getArg(mapping, \"source\", null);\r\n      if (source != null) {\r\n        source = this._sources.at(source);\r\n        source = util.computeSourceURL(\r\n          this.sourceRoot,\r\n          source,\r\n          this._sourceMapURL\r\n        );\r\n      }\r\n      var name = util.getArg(mapping, \"name\", null);\r\n      if (name != null) {\r\n        name = this._names.at(name);\r\n      }\r\n      return {\r\n        source: source,\r\n        line: util.getArg(mapping, \"originalLine\", null),\r\n        column: util.getArg(mapping, \"originalColumn\", null),\r\n        name: name\r\n      };\r\n    }\r\n  }\r\n\r\n  return {\r\n    source: null,\r\n    line: null,\r\n    column: null,\r\n    name: null\r\n  };\r\n};\r\n\r\n/**\r\n * Return true if we have the source content for every source in the source\r\n * map, false otherwise.\r\n */\r\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\r\n  if (!this.sourcesContent) {\r\n    return false;\r\n  }\r\n  return (\r\n    this.sourcesContent.length >= this._sources.size() &&\r\n    !this.sourcesContent.some(function(sc) {\r\n      return sc == null;\r\n    })\r\n  );\r\n};\r\n\r\n/**\r\n * Returns the original source content. The only argument is the url of the\r\n * original source file. Returns null if no original source content is\r\n * available.\r\n */\r\nBasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(\r\n  aSource,\r\n  nullOnMissing\r\n) {\r\n  if (!this.sourcesContent) {\r\n    return null;\r\n  }\r\n\r\n  var index = this._findSourceIndex(aSource);\r\n  if (index >= 0) {\r\n    return this.sourcesContent[index];\r\n  }\r\n\r\n  var relativeSource = aSource;\r\n  if (this.sourceRoot != null) {\r\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\r\n  }\r\n\r\n  var url;\r\n  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\r\n    // XXX: file:// URIs and absolute paths lead to unexpected behavior for\r\n    // many users. We can help them out when they expect file:// URIs to\r\n    // behave like it would if they were running a local HTTP server. See\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\r\n    var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\r\n    if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\r\n      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\r\n    }\r\n\r\n    if (\r\n      (!url.path || url.path == \"/\") &&\r\n      this._sources.has(\"/\" + relativeSource)\r\n    ) {\r\n      return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\r\n    }\r\n  }\r\n\r\n  // This function is used recursively from\r\n  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\r\n  // don't want to throw if we can't find the source - we just want to\r\n  // return null, so we provide a flag to exit gracefully.\r\n  if (nullOnMissing) {\r\n    return null;\r\n  } else {\r\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the generated line and column information for the original source,\r\n * line, and column positions provided. The only argument is an object with\r\n * the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the original source.  The column\r\n *     number is 0-based.\r\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\r\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the generated source, or null.\r\n *     The column number is 0-based.\r\n */\r\nBasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(\r\n  aArgs\r\n) {\r\n  var source = util.getArg(aArgs, \"source\");\r\n  source = this._findSourceIndex(source);\r\n  if (source < 0) {\r\n    return {\r\n      line: null,\r\n      column: null,\r\n      lastColumn: null\r\n    };\r\n  }\r\n\r\n  var needle = {\r\n    source: source,\r\n    originalLine: util.getArg(aArgs, \"line\"),\r\n    originalColumn: util.getArg(aArgs, \"column\")\r\n  };\r\n\r\n  var index = this._findMapping(\r\n    needle,\r\n    this._originalMappings,\r\n    \"originalLine\",\r\n    \"originalColumn\",\r\n    util.compareByOriginalPositions,\r\n    util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND)\r\n  );\r\n\r\n  if (index >= 0) {\r\n    var mapping = this._originalMappings[index];\r\n\r\n    if (mapping.source === needle.source) {\r\n      return {\r\n        line: util.getArg(mapping, \"generatedLine\", null),\r\n        column: util.getArg(mapping, \"generatedColumn\", null),\r\n        lastColumn: util.getArg(mapping, \"lastGeneratedColumn\", null)\r\n      };\r\n    }\r\n  }\r\n\r\n  return {\r\n    line: null,\r\n    column: null,\r\n    lastColumn: null\r\n  };\r\n};\r\n\r\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\r\n\r\n/**\r\n * An IndexedSourceMapConsumer instance represents a parsed source map which\r\n * we can query for information. It differs from BasicSourceMapConsumer in\r\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\r\n * input.\r\n *\r\n * The first parameter is a raw source map (either as a JSON string, or already\r\n * parsed to an object). According to the spec for indexed source maps, they\r\n * have the following attributes:\r\n *\r\n *   - version: Which version of the source map spec this map is following.\r\n *   - file: Optional. The generated file this source map is associated with.\r\n *   - sections: A list of section definitions.\r\n *\r\n * Each value under the \"sections\" field has two fields:\r\n *   - offset: The offset into the original specified at which this section\r\n *       begins to apply, defined as an object with a \"line\" and \"column\"\r\n *       field.\r\n *   - map: A source map definition. This source map could also be indexed,\r\n *       but doesn't have to be.\r\n *\r\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\r\n * specifying a URL to retrieve a source map from, but that's currently\r\n * unsupported.\r\n *\r\n * Here's an example source map, taken from the source map spec[0], but\r\n * modified to omit a section which uses the \"url\" field.\r\n *\r\n *  {\r\n *    version : 3,\r\n *    file: \"app.js\",\r\n *    sections: [{\r\n *      offset: {line:100, column:10},\r\n *      map: {\r\n *        version : 3,\r\n *        file: \"section.js\",\r\n *        sources: [\"foo.js\", \"bar.js\"],\r\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\r\n *        mappings: \"AAAA,E;;ABCDE;\"\r\n *      }\r\n *    }],\r\n *  }\r\n *\r\n * The second parameter, if given, is a string whose value is the URL\r\n * at which the source map was found.  This URL is used to compute the\r\n * sources array.\r\n *\r\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\r\n */\r\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === \"string\") {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  var version = util.getArg(sourceMap, \"version\");\r\n  var sections = util.getArg(sourceMap, \"sections\");\r\n\r\n  if (version != this._version) {\r\n    throw new Error(\"Unsupported version: \" + version);\r\n  }\r\n\r\n  this._sources = new ArraySet();\r\n  this._names = new ArraySet();\r\n\r\n  var lastOffset = {\r\n    line: -1,\r\n    column: 0\r\n  };\r\n  this._sections = sections.map(function(s) {\r\n    if (s.url) {\r\n      // The url field will require support for asynchronicity.\r\n      // See https://github.com/mozilla/source-map/issues/16\r\n      throw new Error(\"Support for url field in sections not implemented.\");\r\n    }\r\n    var offset = util.getArg(s, \"offset\");\r\n    var offsetLine = util.getArg(offset, \"line\");\r\n    var offsetColumn = util.getArg(offset, \"column\");\r\n\r\n    if (\r\n      offsetLine < lastOffset.line ||\r\n      (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)\r\n    ) {\r\n      throw new Error(\"Section offsets must be ordered and non-overlapping.\");\r\n    }\r\n    lastOffset = offset;\r\n\r\n    return {\r\n      generatedOffset: {\r\n        // The offset fields are 0-based, but we use 1-based indices when\r\n        // encoding/decoding from VLQ.\r\n        generatedLine: offsetLine + 1,\r\n        generatedColumn: offsetColumn + 1\r\n      },\r\n      consumer: new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL)\r\n    };\r\n  });\r\n}\r\n\r\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\r\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nIndexedSourceMapConsumer.prototype._version = 3;\r\n\r\n/**\r\n * The list of original sources.\r\n */\r\nObject.defineProperty(IndexedSourceMapConsumer.prototype, \"sources\", {\r\n  get: function() {\r\n    var sources = [];\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\r\n        sources.push(this._sections[i].consumer.sources[j]);\r\n      }\r\n    }\r\n    return sources;\r\n  }\r\n});\r\n\r\n/**\r\n * Returns the original source, line, and column information for the generated\r\n * source's line and column positions provided. The only argument is an object\r\n * with the following properties:\r\n *\r\n *   - line: The line number in the generated source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the generated source.  The column\r\n *     number is 0-based.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - source: The original source file, or null.\r\n *   - line: The line number in the original source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the original source, or null.  The\r\n *     column number is 0-based.\r\n *   - name: The original identifier, or null.\r\n */\r\nIndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(\r\n  aArgs\r\n) {\r\n  var needle = {\r\n    generatedLine: util.getArg(aArgs, \"line\"),\r\n    generatedColumn: util.getArg(aArgs, \"column\")\r\n  };\r\n\r\n  // Find the section containing the generated position we're trying to map\r\n  // to an original position.\r\n  var sectionIndex = binarySearch.search(needle, this._sections, function(\r\n    needle,\r\n    section\r\n  ) {\r\n    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\r\n    if (cmp) {\r\n      return cmp;\r\n    }\r\n\r\n    return needle.generatedColumn + 1 - section.generatedOffset.generatedColumn;\r\n  });\r\n  var section = this._sections[sectionIndex];\r\n\r\n  if (!section) {\r\n    return {\r\n      source: null,\r\n      line: null,\r\n      column: null,\r\n      name: null\r\n    };\r\n  }\r\n\r\n  return section.consumer.originalPositionFor({\r\n    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\r\n    column:\r\n      needle.generatedColumn -\r\n      (section.generatedOffset.generatedLine === needle.generatedLine\r\n        ? section.generatedOffset.generatedColumn - 1\r\n        : 0),\r\n    bias: aArgs.bias\r\n  });\r\n};\r\n\r\n/**\r\n * Return true if we have the source content for every source in the source\r\n * map, false otherwise.\r\n */\r\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\r\n  return this._sections.every(function(s) {\r\n    return s.consumer.hasContentsOfAllSources();\r\n  });\r\n};\r\n\r\n/**\r\n * Returns the original source content. The only argument is the url of the\r\n * original source file. Returns null if no original source content is\r\n * available.\r\n */\r\nIndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(\r\n  aSource,\r\n  nullOnMissing\r\n) {\r\n  for (var i = 0; i < this._sections.length; i++) {\r\n    var section = this._sections[i];\r\n\r\n    var content = section.consumer.sourceContentFor(aSource, true);\r\n    if (content) {\r\n      return content;\r\n    }\r\n  }\r\n  if (nullOnMissing) {\r\n    return null;\r\n  } else {\r\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the generated line and column information for the original source,\r\n * line, and column positions provided. The only argument is an object with\r\n * the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the original source.  The column\r\n *     number is 0-based.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the generated source, or null.\r\n *     The column number is 0-based.\r\n */\r\nIndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(\r\n  aArgs\r\n) {\r\n  for (var i = 0; i < this._sections.length; i++) {\r\n    var section = this._sections[i];\r\n\r\n    // Only consider this section if the requested source is in the list of\r\n    // sources of the consumer.\r\n    if (\r\n      section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1\r\n    ) {\r\n      continue;\r\n    }\r\n    var generatedPosition = section.consumer.generatedPositionFor(aArgs);\r\n    if (generatedPosition) {\r\n      var ret = {\r\n        line:\r\n          generatedPosition.line + (section.generatedOffset.generatedLine - 1),\r\n        column:\r\n          generatedPosition.column +\r\n          (section.generatedOffset.generatedLine === generatedPosition.line\r\n            ? section.generatedOffset.generatedColumn - 1\r\n            : 0)\r\n      };\r\n      return ret;\r\n    }\r\n  }\r\n\r\n  return {\r\n    line: null,\r\n    column: null\r\n  };\r\n};\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nIndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(\r\n  aStr,\r\n  aSourceRoot\r\n) {\r\n  const generatedMappings = (this.__generatedMappingsUnsorted = []);\r\n  const originalMappings = (this.__originalMappingsUnsorted = []);\r\n  for (var i = 0; i < this._sections.length; i++) {\r\n    var section = this._sections[i];\r\n    var sectionMappings = section.consumer._generatedMappings;\r\n    for (var j = 0; j < sectionMappings.length; j++) {\r\n      var mapping = sectionMappings[j];\r\n\r\n      var source = null;\r\n      if (mapping.source != null) {\r\n        source = section.consumer._sources.at(mapping.source);\r\n        source = util.computeSourceURL(\r\n          section.consumer.sourceRoot,\r\n          source,\r\n          this._sourceMapURL\r\n        );\r\n        this._sources.add(source);\r\n        source = this._sources.indexOf(source);\r\n      }\r\n\r\n      var name = null;\r\n      if (mapping.name != null) {\r\n        name = section.consumer._names.at(mapping.name);\r\n        this._names.add(name);\r\n        name = this._names.indexOf(name);\r\n      }\r\n\r\n      // The mappings coming from the consumer for the section have\r\n      // generated positions relative to the start of the section, so we\r\n      // need to offset them to be relative to the start of the concatenated\r\n      // generated file.\r\n      var adjustedMapping = {\r\n        source: source,\r\n        generatedLine:\r\n          mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\r\n        generatedColumn:\r\n          mapping.generatedColumn +\r\n          (section.generatedOffset.generatedLine === mapping.generatedLine\r\n            ? section.generatedOffset.generatedColumn - 1\r\n            : 0),\r\n        originalLine: mapping.originalLine,\r\n        originalColumn: mapping.originalColumn,\r\n        name: name\r\n      };\r\n\r\n      generatedMappings.push(adjustedMapping);\r\n      if (typeof adjustedMapping.originalLine === \"number\") {\r\n        originalMappings.push(adjustedMapping);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nIndexedSourceMapConsumer.prototype.computeColumnSpans = function IndexedSourceMapConsumer_computeColumnSpans() {\r\n  for (var i = 0; i < this._sections.length; i++) {\r\n    this._sections[i].consumer.computeColumnSpans();\r\n  }\r\n};\r\n\r\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nexports.GREATEST_LOWER_BOUND = 1;\r\nexports.LEAST_UPPER_BOUND = 2;\r\n\r\n/**\r\n * Recursive implementation of binary search.\r\n *\r\n * @param aLow Indices here and lower do not contain the needle.\r\n * @param aHigh Indices here and higher do not contain the needle.\r\n * @param aNeedle The element being searched for.\r\n * @param aHaystack The non-empty array being searched.\r\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n */\r\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\r\n  // This function terminates when one of the following is true:\r\n  //\r\n  //   1. We find the exact element we are looking for.\r\n  //\r\n  //   2. We did not find the exact element, but we can return the index of\r\n  //      the next-closest element.\r\n  //\r\n  //   3. We did not find the exact element, and there is no next-closest\r\n  //      element than the one we are searching for, so we return -1.\r\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\r\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\r\n  if (cmp === 0) {\r\n    // Found the element we are looking for.\r\n    return mid;\r\n  } else if (cmp > 0) {\r\n    // Our needle is greater than aHaystack[mid].\r\n    if (aHigh - mid > 1) {\r\n      // The element is in the upper half.\r\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // The exact needle element was not found in this haystack. Determine if\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return aHigh < aHaystack.length ? aHigh : -1;\r\n    } else {\r\n      return mid;\r\n    }\r\n  } else {\r\n    // Our needle is less than aHaystack[mid].\r\n    if (mid - aLow > 1) {\r\n      // The element is in the lower half.\r\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return mid;\r\n    } else {\r\n      return aLow < 0 ? -1 : aLow;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This is an implementation of binary search which will always try and return\r\n * the index of the closest element if there is no exact hit. This is because\r\n * mappings between original and generated line/col pairs are single points,\r\n * and there is an implicit region between each of them, so a miss just means\r\n * that you aren't on the very start of a region.\r\n *\r\n * @param aNeedle The element you are looking for.\r\n * @param aHaystack The array that is being searched.\r\n * @param aCompare A function which takes the needle and an element in the\r\n *     array and returns -1, 0, or 1 depending on whether the needle is less\r\n *     than, equal to, or greater than the element, respectively.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\r\n */\r\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\r\n  if (aHaystack.length === 0) {\r\n    return -1;\r\n  }\r\n\r\n  var index = recursiveSearch(\r\n    -1,\r\n    aHaystack.length,\r\n    aNeedle,\r\n    aHaystack,\r\n    aCompare,\r\n    aBias || exports.GREATEST_LOWER_BOUND\r\n  );\r\n  if (index < 0) {\r\n    return -1;\r\n  }\r\n\r\n  // We have found either the exact element, or the next-closest element than\r\n  // the one we are searching for. However, there may be more than one such\r\n  // element. Make sure we always return the smallest of these.\r\n  while (index - 1 >= 0) {\r\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\r\n      break;\r\n    }\r\n    --index;\r\n  }\r\n\r\n  return index;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\n// It turns out that some (most?) JavaScript engines don't self-host\r\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\r\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\r\n// custom comparator function, calling back and forth between the VM's C++ and\r\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\r\n// worse generated code for the comparator function than would be optimal. In\r\n// fact, when sorting with a comparator, these costs outweigh the benefits of\r\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\r\n// a ~3500ms mean speed-up in `bench/bench.html`.\r\n\r\n// Capture Math.random() now, to avoid problems in case a test mocks it later.\r\n// If Math.random() is mocked to return a constant value, quickSort may become\r\n// O(n^2) when invoked on already-sorted data.\r\nvar random = Math.random;\r\n\r\n/**\r\n * Swap the elements indexed by `x` and `y` in the array `ary`.\r\n *\r\n * @param {Array} ary\r\n *        The array.\r\n * @param {Number} x\r\n *        The index of the first item.\r\n * @param {Number} y\r\n *        The index of the second item.\r\n */\r\nfunction swap(ary, x, y) {\r\n  var temp = ary[x];\r\n  ary[x] = ary[y];\r\n  ary[y] = temp;\r\n}\r\n\r\n/**\r\n * Returns a random integer within the range `low .. high` inclusive.\r\n *\r\n * @param {Number} low\r\n *        The lower bound on the range.\r\n * @param {Number} high\r\n *        The upper bound on the range.\r\n */\r\nfunction randomIntInRange(low, high) {\r\n  return Math.round(low + random() * (high - low));\r\n}\r\n\r\n/**\r\n * The Quick Sort algorithm.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n * @param {Number} p\r\n *        Start index of the array\r\n * @param {Number} r\r\n *        End index of the array\r\n */\r\nfunction doQuickSort(ary, comparator, p, r) {\r\n  // If our lower bound is less than our upper bound, we (1) partition the\r\n  // array into two pieces and (2) recurse on each half. If it is not, this is\r\n  // the empty array and our base case.\r\n\r\n  if (p < r) {\r\n    // (1) Partitioning.\r\n    //\r\n    // The partitioning chooses a pivot between `p` and `r` and moves all\r\n    // elements that are less than or equal to the pivot to the before it, and\r\n    // all the elements that are greater than it after it. The effect is that\r\n    // once partition is done, the pivot is in the exact place it will be when\r\n    // the array is put in sorted order, and it will not need to be moved\r\n    // again. This runs in O(n log n) time.\r\n\r\n    // Always choose a random pivot so that an input array which is reverse\r\n    // sorted does not cause O(n^2) running time.\r\n    var pivotIndex = randomIntInRange(p, r);\r\n    var i = p - 1;\r\n\r\n    swap(ary, pivotIndex, r);\r\n    var pivot = ary[r];\r\n\r\n    // Immediately after `j` is incremented in this loop, the following hold\r\n    // true:\r\n    //\r\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\r\n    //\r\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\r\n    for (var j = p; j < r; j++) {\r\n      if (comparator(ary[j], pivot) <= 0) {\r\n        i += 1;\r\n        swap(ary, i, j);\r\n      }\r\n    }\r\n\r\n    swap(ary, i + 1, j);\r\n    var q = i + 1;\r\n\r\n    // (2) Recurse on each half.\r\n\r\n    doQuickSort(ary, comparator, p, q - 1);\r\n    doQuickSort(ary, comparator, q + 1, r);\r\n  }\r\n}\r\n\r\n/**\r\n * Sort the given array in-place with the given comparator function.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n */\r\nexports.quickSort = function(ary, comparator) {\r\n  doQuickSort(ary, comparator, 0, ary.length - 1);\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\r\nvar util = require(\"./util\");\r\n\r\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\r\n// operating systems these days (capturing the result).\r\nvar REGEX_NEWLINE = /(\\r?\\n)/;\r\n\r\n// Newline character code for charCodeAt() comparisons\r\nvar NEWLINE_CODE = 10;\r\n\r\n// Private symbol for identifying `SourceNode`s when multiple versions of\r\n// the source-map library are loaded. This MUST NOT CHANGE across\r\n// versions!\r\nvar isSourceNode = \"$$$isSourceNode$$$\";\r\n\r\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\r\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\r\n  this.children = [];\r\n  this.sourceContents = {};\r\n  this.line = aLine == null ? null : aLine;\r\n  this.column = aColumn == null ? null : aColumn;\r\n  this.source = aSource == null ? null : aSource;\r\n  this.name = aName == null ? null : aName;\r\n  this[isSourceNode] = true;\r\n  if (aChunks != null) this.add(aChunks);\r\n}\r\n\r\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\r\nSourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(\r\n  aGeneratedCode,\r\n  aSourceMapConsumer,\r\n  aRelativePath\r\n) {\r\n  // The SourceNode we want to fill with the generated code\r\n  // and the SourceMap\r\n  var node = new SourceNode();\r\n\r\n  // All even indices of this array are one line of the generated code,\r\n  // while all odd indices are the newlines between two adjacent lines\r\n  // (since `REGEX_NEWLINE` captures its match).\r\n  // Processed fragments are accessed by calling `shiftNextLine`.\r\n  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\r\n  var remainingLinesIndex = 0;\r\n  var shiftNextLine = function() {\r\n    var lineContents = getNextLine();\r\n    // The last line of a file might not have a newline.\r\n    var newLine = getNextLine() || \"\";\r\n    return lineContents + newLine;\r\n\r\n    function getNextLine() {\r\n      return remainingLinesIndex < remainingLines.length\r\n        ? remainingLines[remainingLinesIndex++]\r\n        : undefined;\r\n    }\r\n  };\r\n\r\n  // We need to remember the position of \"remainingLines\"\r\n  var lastGeneratedLine = 1,\r\n    lastGeneratedColumn = 0;\r\n\r\n  // The generate SourceNodes we need a code range.\r\n  // To extract it current and last mapping is used.\r\n  // Here we store the last mapping.\r\n  var lastMapping = null;\r\n\r\n  aSourceMapConsumer.eachMapping(function(mapping) {\r\n    if (lastMapping !== null) {\r\n      // We add the code from \"lastMapping\" to \"mapping\":\r\n      // First check if there is a new line in between.\r\n      if (lastGeneratedLine < mapping.generatedLine) {\r\n        // Associate first line with \"lastMapping\"\r\n        addMappingWithCode(lastMapping, shiftNextLine());\r\n        lastGeneratedLine++;\r\n        lastGeneratedColumn = 0;\r\n        // The remaining code is added without mapping\r\n      } else {\r\n        // There is no new line in between.\r\n        // Associate the code between \"lastGeneratedColumn\" and\r\n        // \"mapping.generatedColumn\" with \"lastMapping\"\r\n        var nextLine = remainingLines[remainingLinesIndex] || \"\";\r\n        var code = nextLine.substr(\r\n          0,\r\n          mapping.generatedColumn - lastGeneratedColumn\r\n        );\r\n        remainingLines[remainingLinesIndex] = nextLine.substr(\r\n          mapping.generatedColumn - lastGeneratedColumn\r\n        );\r\n        lastGeneratedColumn = mapping.generatedColumn;\r\n        addMappingWithCode(lastMapping, code);\r\n        // No more remaining code, continue\r\n        lastMapping = mapping;\r\n        return;\r\n      }\r\n    }\r\n    // We add the generated code until the first mapping\r\n    // to the SourceNode without any mapping.\r\n    // Each line is added as separate string.\r\n    while (lastGeneratedLine < mapping.generatedLine) {\r\n      node.add(shiftNextLine());\r\n      lastGeneratedLine++;\r\n    }\r\n    if (lastGeneratedColumn < mapping.generatedColumn) {\r\n      var nextLine = remainingLines[remainingLinesIndex] || \"\";\r\n      node.add(nextLine.substr(0, mapping.generatedColumn));\r\n      remainingLines[remainingLinesIndex] = nextLine.substr(\r\n        mapping.generatedColumn\r\n      );\r\n      lastGeneratedColumn = mapping.generatedColumn;\r\n    }\r\n    lastMapping = mapping;\r\n  }, this);\r\n  // We have processed all mappings.\r\n  if (remainingLinesIndex < remainingLines.length) {\r\n    if (lastMapping) {\r\n      // Associate the remaining code in the current line with \"lastMapping\"\r\n      addMappingWithCode(lastMapping, shiftNextLine());\r\n    }\r\n    // and add the remaining lines without any mapping\r\n    node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\r\n  }\r\n\r\n  // Copy sourcesContent into SourceNode\r\n  aSourceMapConsumer.sources.forEach(function(sourceFile) {\r\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n    if (content != null) {\r\n      if (aRelativePath != null) {\r\n        sourceFile = util.join(aRelativePath, sourceFile);\r\n      }\r\n      node.setSourceContent(sourceFile, content);\r\n    }\r\n  });\r\n\r\n  return node;\r\n\r\n  function addMappingWithCode(mapping, code) {\r\n    if (mapping === null || mapping.source === undefined) {\r\n      node.add(code);\r\n    } else {\r\n      var source =\r\n        aRelativePath && mapping.source\r\n          ? util.join(aRelativePath, mapping.source)\r\n          : mapping.source;\r\n      node.add(\r\n        new SourceNode(\r\n          mapping.originalLine,\r\n          mapping.originalColumn,\r\n          source,\r\n          code,\r\n          mapping.name\r\n        )\r\n      );\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    aChunk.forEach(function(chunk) {\r\n      this.add(chunk);\r\n    }, this);\r\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    if (aChunk) {\r\n      this.children.push(aChunk);\r\n    }\r\n  } else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\r\n        aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    for (var i = aChunk.length - 1; i >= 0; i--) {\r\n      this.prepend(aChunk[i]);\r\n    }\r\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    this.children.unshift(aChunk);\r\n  } else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\r\n        aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\r\n  var chunk;\r\n  for (var i = 0, len = this.children.length; i < len; i++) {\r\n    chunk = this.children[i];\r\n    if (chunk[isSourceNode]) {\r\n      chunk.walk(aFn);\r\n    } else {\r\n      if (chunk !== \"\") {\r\n        aFn(chunk, {\r\n          source: this.source,\r\n          line: this.line,\r\n          column: this.column,\r\n          name: this.name\r\n        });\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\r\nSourceNode.prototype.join = function SourceNode_join(aSep) {\r\n  var newChildren;\r\n  var i;\r\n  var len = this.children.length;\r\n  if (len > 0) {\r\n    newChildren = [];\r\n    for (i = 0; i < len - 1; i++) {\r\n      newChildren.push(this.children[i]);\r\n      newChildren.push(aSep);\r\n    }\r\n    newChildren.push(this.children[i]);\r\n    this.children = newChildren;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\r\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(\r\n  aPattern,\r\n  aReplacement\r\n) {\r\n  var lastChild = this.children[this.children.length - 1];\r\n  if (lastChild[isSourceNode]) {\r\n    lastChild.replaceRight(aPattern, aReplacement);\r\n  } else if (typeof lastChild === \"string\") {\r\n    this.children[this.children.length - 1] = lastChild.replace(\r\n      aPattern,\r\n      aReplacement\r\n    );\r\n  } else {\r\n    this.children.push(\"\".replace(aPattern, aReplacement));\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\r\nSourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(\r\n  aSourceFile,\r\n  aSourceContent\r\n) {\r\n  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\r\n};\r\n\r\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(\r\n  aFn\r\n) {\r\n  for (var i = 0, len = this.children.length; i < len; i++) {\r\n    if (this.children[i][isSourceNode]) {\r\n      this.children[i].walkSourceContents(aFn);\r\n    }\r\n  }\r\n\r\n  var sources = Object.keys(this.sourceContents);\r\n  for (var i = 0, len = sources.length; i < len; i++) {\r\n    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\r\n  }\r\n};\r\n\r\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\r\nSourceNode.prototype.toString = function SourceNode_toString() {\r\n  var str = \"\";\r\n  this.walk(function(chunk) {\r\n    str += chunk;\r\n  });\r\n  return str;\r\n};\r\n\r\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\r\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(\r\n  aArgs\r\n) {\r\n  var generated = {\r\n    code: \"\",\r\n    line: 1,\r\n    column: 0\r\n  };\r\n  var map = new SourceMapGenerator(aArgs);\r\n  var sourceMappingActive = false;\r\n  var lastOriginalSource = null;\r\n  var lastOriginalLine = null;\r\n  var lastOriginalColumn = null;\r\n  var lastOriginalName = null;\r\n  this.walk(function(chunk, original) {\r\n    generated.code += chunk;\r\n    if (\r\n      original.source !== null &&\r\n      original.line !== null &&\r\n      original.column !== null\r\n    ) {\r\n      if (\r\n        lastOriginalSource !== original.source ||\r\n        lastOriginalLine !== original.line ||\r\n        lastOriginalColumn !== original.column ||\r\n        lastOriginalName !== original.name\r\n      ) {\r\n        map.addMapping({\r\n          source: original.source,\r\n          original: {\r\n            line: original.line,\r\n            column: original.column\r\n          },\r\n          generated: {\r\n            line: generated.line,\r\n            column: generated.column\r\n          },\r\n          name: original.name\r\n        });\r\n      }\r\n      lastOriginalSource = original.source;\r\n      lastOriginalLine = original.line;\r\n      lastOriginalColumn = original.column;\r\n      lastOriginalName = original.name;\r\n      sourceMappingActive = true;\r\n    } else if (sourceMappingActive) {\r\n      map.addMapping({\r\n        generated: {\r\n          line: generated.line,\r\n          column: generated.column\r\n        }\r\n      });\r\n      lastOriginalSource = null;\r\n      sourceMappingActive = false;\r\n    }\r\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\r\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\r\n        generated.line++;\r\n        generated.column = 0;\r\n        // Mappings end at eol\r\n        if (idx + 1 === length) {\r\n          lastOriginalSource = null;\r\n          sourceMappingActive = false;\r\n        } else if (sourceMappingActive) {\r\n          map.addMapping({\r\n            source: original.source,\r\n            original: {\r\n              line: original.line,\r\n              column: original.column\r\n            },\r\n            generated: {\r\n              line: generated.line,\r\n              column: generated.column\r\n            },\r\n            name: original.name\r\n          });\r\n        }\r\n      } else {\r\n        generated.column++;\r\n      }\r\n    }\r\n  });\r\n  this.walkSourceContents(function(sourceFile, sourceContent) {\r\n    map.setSourceContent(sourceFile, sourceContent);\r\n  });\r\n\r\n  return { code: generated.code, map: map };\r\n};\r\n\r\nexports.SourceNode = SourceNode;\r\n"],"sourceRoot":""}