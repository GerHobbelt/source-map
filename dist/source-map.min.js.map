{"version":3,"sources":["webpack://sourceMap/webpack/universalModuleDefinition","webpack://sourceMap/webpack/bootstrap","webpack://sourceMap/./lib/util.js","webpack://sourceMap/./lib/array-set.js","webpack://sourceMap/./lib/base64-vlq.js","webpack://sourceMap/./lib/source-map-generator.js","webpack://sourceMap/./lib/source-node.js","webpack://sourceMap/./lib/quick-sort.js","webpack://sourceMap/./lib/binary-search.js","webpack://sourceMap/./lib/source-map-consumer.js","webpack://sourceMap/./lib/mapping-list.js","webpack://sourceMap/./lib/base64.js","webpack://sourceMap/./source-map.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","getArg","aArgs","aName","aDefaultValue","arguments","length","Error","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","MAX_CACHED_INPUTS","normalize","f","cache","input","temp","result","unshift","pop","lruMemoize","aPath","isAbsolute","parts","start","indexOf","push","slice","part","up","splice","join","aRoot","aPathUrl","aRootUrl","joined","charAt","replace","test","relative","level","index","lastIndexOf","Array","substr","supportsNullProto","identity","isProtoString","charCodeAt","strcmp","aStr1","aStr2","toSetString","aStr","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","source","originalLine","originalColumn","generatedColumn","generatedLine","compareByGeneratedPositionsDeflated","onlyCompareGenerated","compareByGeneratedPositionsInflated","parseSourceMapInput","str","JSON","parse","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","parsed","substring","util","has","hasNativeMap","Map","ArraySet","this","_array","_set","fromArray","aArray","aAllowDuplicates","set","len","add","size","getOwnPropertyNames","sStr","isDuplicate","idx","at","aIdx","toArray","base64","encode","aValue","digit","encoded","vlq","toVLQSigned","VLQ_BASE","decode","aIndex","aOutParam","continuation","strLen","shift","shifted","fromVLQSigned","rest","base64VLQ","MappingList","SourceMapGenerator","_file","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","_version","fromSourceMap","aSourceMapConsumer","generator","file","eachMapping","mapping","newMapping","generated","line","column","original","addMapping","sources","forEach","sourceFile","sourceRelative","content","sourceContentFor","setSourceContent","_validateMapping","String","aSourceFile","aSourceContent","keys","applySourceMap","aSourceMapPath","newSources","newNames","unsortedForEach","originalPositionFor","aGenerated","aOriginal","aSource","stringify","_serializeMappings","next","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","mappings","_generateSourcesContent","aSources","aSourceRoot","map","toJSON","version","names","sourcesContent","toString","REGEX_NEWLINE","isSourceNode","SourceNode","aLine","aColumn","aChunks","children","sourceContents","fromStringWithSourceMap","aGeneratedCode","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","getNextLine","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","code","nextLine","addMappingWithCode","aChunk","isArray","chunk","TypeError","prepend","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","walkSourceContents","toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","sourceContent","random","Math","swap","ary","x","y","doQuickSort","comparator","low","high","round","randomIntInRange","pivot","j","q","quickSort","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","search","aNeedle","aHaystack","aCompare","aBias","recursiveSearch","aLow","aHigh","mid","floor","binarySearch","SourceMapConsumer","aSourceMap","aSourceMapURL","sourceMap","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","_absoluteSources","_sourceMapURL","Mapping","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","consumer","__generatedMappings","configurable","_parseMappings","__originalMappings","_charIsMappingSeparator","GENERATED_ORDER","ORIGINAL_ORDER","aCallback","aContext","aOrder","context","_generatedMappings","_originalMappings","allGeneratedPositionsFor","needle","_findSourceIndex","_findMapping","lastColumn","relativeSource","smc","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","segment","end","cachedSegments","originalMappings","aMappings","aLineName","aColumnName","aComparator","computeColumnSpans","nextMapping","Infinity","hasContentsOfAllSources","some","sc","nullOnMissing","fileUriAbsPath","generatedPositionFor","constructor","sectionIndex","section","bias","every","generatedPosition","sectionMappings","adjustedMapping","_sorted","_last","aThisArg","aMapping","lineA","lineB","columnA","columnB","generatedPositionAfter","sort","intToCharMap","number","charCode"],"mappings":"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","file":"source-map.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sourceMap\"] = factory();\n\telse\n\t\troot[\"sourceMap\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\n/**\r\n * This is a helper function for getting values from parameter/options\r\n * objects.\r\n *\r\n * @param args The object we are extracting values from\r\n * @param name The name of the property we are getting.\r\n * @param defaultValue An optional value to return if the property is missing\r\n * from the object. If this is not specified and the property is missing, an\r\n * error will be thrown.\r\n */\r\nfunction getArg(aArgs, aName, aDefaultValue) {\r\n  if (aName in aArgs) {\r\n    return aArgs[aName];\r\n  } else if (arguments.length === 3) {\r\n    return aDefaultValue;\r\n  } else {\r\n    throw new Error('\"' + aName + '\" is a required argument.');\r\n  }\r\n}\r\nexports.getArg = getArg;\r\n\r\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\r\nvar dataUrlRegexp = /^data:.+\\,.+$/;\r\n\r\nfunction urlParse(aUrl) {\r\n  var match = aUrl.match(urlRegexp);\r\n  if (!match) {\r\n    return null;\r\n  }\r\n  return {\r\n    scheme: match[1],\r\n    auth: match[2],\r\n    host: match[3],\r\n    port: match[4],\r\n    path: match[5]\r\n  };\r\n}\r\nexports.urlParse = urlParse;\r\n\r\nfunction urlGenerate(aParsedUrl) {\r\n  var url = '';\r\n  if (aParsedUrl.scheme) {\r\n    url += aParsedUrl.scheme + ':';\r\n  }\r\n  url += '//';\r\n  if (aParsedUrl.auth) {\r\n    url += aParsedUrl.auth + '@';\r\n  }\r\n  if (aParsedUrl.host) {\r\n    url += aParsedUrl.host;\r\n  }\r\n  if (aParsedUrl.port) {\r\n    url += \":\" + aParsedUrl.port\r\n  }\r\n  if (aParsedUrl.path) {\r\n    url += aParsedUrl.path;\r\n  }\r\n  return url;\r\n}\r\nexports.urlGenerate = urlGenerate;\r\n\r\nconst MAX_CACHED_INPUTS = 32;\r\n\r\n/**\r\n * Takes some function `f(input) -> result` and returns a memoized version of\r\n * `f`.\r\n *\r\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\r\n * memoization is a dumb-simple, linear least-recently-used cache.\r\n */\r\nfunction lruMemoize(f) {\r\n  const cache = [];\r\n\r\n  return function (input) {\r\n    for (var i = 0; i < cache.length; i++) {\r\n      if (cache[i].input === input) {\r\n        var temp = cache[0];\r\n        cache[0] = cache[i];\r\n        cache[i] = temp;\r\n        return cache[0].result;\r\n      }\r\n    }\r\n\r\n    var result = f(input);\r\n\r\n    cache.unshift({\r\n      input,\r\n      result,\r\n    });\r\n\r\n    if (cache.length > MAX_CACHED_INPUTS) {\r\n      cache.pop();\r\n    }\r\n\r\n    return result;\r\n  };\r\n}\r\n\r\n/**\r\n * Normalizes a path, or the path portion of a URL:\r\n *\r\n * - Replaces consecutive slashes with one slash.\r\n * - Removes unnecessary '.' parts.\r\n * - Removes unnecessary '<dir>/..' parts.\r\n *\r\n * Based on code in the Node.js 'path' core module.\r\n *\r\n * @param aPath The path or url to normalize.\r\n */\r\nvar normalize = lruMemoize(function normalize(aPath) {\r\n  var path = aPath;\r\n  var url = urlParse(aPath);\r\n  if (url) {\r\n    if (!url.path) {\r\n      return aPath;\r\n    }\r\n    path = url.path;\r\n  }\r\n  var isAbsolute = exports.isAbsolute(path);\r\n\r\n  // Split the path into parts between `/` characters. This is much faster than\r\n  // using `.split(/\\/+/g)`.\r\n  var parts = [];\r\n  var start = 0;\r\n  var i = 0;\r\n  while (true) {\r\n    start = i;\r\n    i = path.indexOf(\"/\", start);\r\n    if (i === -1) {\r\n      parts.push(path.slice(start));\r\n      break;\r\n    } else {\r\n      parts.push(path.slice(start, i));\r\n      while (i < path.length && path[i] === \"/\") {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\r\n    part = parts[i];\r\n    if (part === '.') {\r\n      parts.splice(i, 1);\r\n    } else if (part === '..') {\r\n      up++;\r\n    } else if (up > 0) {\r\n      if (part === '') {\r\n        // The first part is blank if the path is absolute. Trying to go\r\n        // above the root is a no-op. Therefore we can remove all '..' parts\r\n        // directly after the root.\r\n        parts.splice(i + 1, up);\r\n        up = 0;\r\n      } else {\r\n        parts.splice(i, 2);\r\n        up--;\r\n      }\r\n    }\r\n  }\r\n  path = parts.join('/');\r\n\r\n  if (path === '') {\r\n    path = isAbsolute ? '/' : '.';\r\n  }\r\n\r\n  if (url) {\r\n    url.path = path;\r\n    return urlGenerate(url);\r\n  }\r\n  return path;\r\n});\r\nexports.normalize = normalize;\r\n\r\n/**\r\n * Joins two paths/URLs.\r\n *\r\n * @param aRoot The root path or URL.\r\n * @param aPath The path or URL to be joined with the root.\r\n *\r\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\r\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\r\n *   first.\r\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\r\n *   is updated with the result and aRoot is returned. Otherwise the result\r\n *   is returned.\r\n *   - If aPath is absolute, the result is aPath.\r\n *   - Otherwise the two paths are joined with a slash.\r\n * - Joining for example 'http://' and 'www.example.com' is also supported.\r\n */\r\nfunction join(aRoot, aPath) {\r\n  if (aRoot === \"\") {\r\n    aRoot = \".\";\r\n  }\r\n  if (aPath === \"\") {\r\n    aPath = \".\";\r\n  }\r\n  var aPathUrl = urlParse(aPath);\r\n  var aRootUrl = urlParse(aRoot);\r\n  if (aRootUrl) {\r\n    aRoot = aRootUrl.path || '/';\r\n  }\r\n\r\n  // `join(foo, '//www.example.org')`\r\n  if (aPathUrl && !aPathUrl.scheme) {\r\n    if (aRootUrl) {\r\n      aPathUrl.scheme = aRootUrl.scheme;\r\n    }\r\n    return urlGenerate(aPathUrl);\r\n  }\r\n\r\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\r\n    return aPath;\r\n  }\r\n\r\n  // `join('http://', 'www.example.com')`\r\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\r\n    aRootUrl.host = aPath;\r\n    return urlGenerate(aRootUrl);\r\n  }\r\n\r\n  var joined = aPath.charAt(0) === '/'\r\n    ? aPath\r\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\r\n\r\n  if (aRootUrl) {\r\n    aRootUrl.path = joined;\r\n    return urlGenerate(aRootUrl);\r\n  }\r\n  return joined;\r\n}\r\nexports.join = join;\r\n\r\nexports.isAbsolute = function (aPath) {\r\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\r\n};\r\n\r\n/**\r\n * Make a path relative to a URL or another path.\r\n *\r\n * @param aRoot The root path or URL.\r\n * @param aPath The path or URL to be made relative to aRoot.\r\n */\r\nfunction relative(aRoot, aPath) {\r\n  if (aRoot === \"\") {\r\n    aRoot = \".\";\r\n  }\r\n\r\n  aRoot = aRoot.replace(/\\/$/, '');\r\n\r\n  // It is possible for the path to be above the root. In this case, simply\r\n  // checking whether the root is a prefix of the path won't work. Instead, we\r\n  // need to remove components from the root one by one, until either we find\r\n  // a prefix that fits, or we run out of components to remove.\r\n  var level = 0;\r\n  while (aPath.indexOf(aRoot + '/') !== 0) {\r\n    var index = aRoot.lastIndexOf(\"/\");\r\n    if (index < 0) {\r\n      return aPath;\r\n    }\r\n\r\n    // If the only part of the root that is left is the scheme (i.e. http://,\r\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\r\n    // have exhausted all components, so the path is not relative to the root.\r\n    aRoot = aRoot.slice(0, index);\r\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\r\n      return aPath;\r\n    }\r\n\r\n    ++level;\r\n  }\r\n\r\n  // Make sure we add a \"../\" for each component we removed from the root.\r\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\r\n}\r\nexports.relative = relative;\r\n\r\nvar supportsNullProto = (function () {\r\n  var obj = Object.create(null);\r\n  return !('__proto__' in obj);\r\n}());\r\n\r\nfunction identity (s) {\r\n  return s;\r\n}\r\n\r\n/**\r\n * Because behavior goes wacky when you set `__proto__` on objects, we\r\n * have to prefix all the strings in our set with an arbitrary character.\r\n *\r\n * See https://github.com/mozilla/source-map/pull/31 and\r\n * https://github.com/mozilla/source-map/issues/30\r\n *\r\n * @param String aStr\r\n */\r\nfunction toSetString(aStr) {\r\n  if (isProtoString(aStr)) {\r\n    return '$' + aStr;\r\n  }\r\n\r\n  return aStr;\r\n}\r\nexports.toSetString = supportsNullProto ? identity : toSetString;\r\n\r\nfunction fromSetString(aStr) {\r\n  if (isProtoString(aStr)) {\r\n    return aStr.slice(1);\r\n  }\r\n\r\n  return aStr;\r\n}\r\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\r\n\r\nfunction isProtoString(s) {\r\n  if (!s) {\r\n    return false;\r\n  }\r\n\r\n  var length = s.length;\r\n\r\n  if (length < 9 /* \"__proto__\".length */) {\r\n    return false;\r\n  }\r\n\r\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\r\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\r\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\r\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\r\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\r\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\r\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\r\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\r\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\r\n    return false;\r\n  }\r\n\r\n  for (var i = length - 10; i >= 0; i--) {\r\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Comparator between two mappings where the original positions are compared.\r\n *\r\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\r\n * mappings with the same original source/line/column, but different generated\r\n * line and column the same. Useful when searching for a mapping with a\r\n * stubbed out mapping.\r\n */\r\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\r\n  var cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0 || onlyCompareOriginal) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByOriginalPositions = compareByOriginalPositions;\r\n\r\n/**\r\n * Comparator between two mappings with deflated source and name indices where\r\n * the generated positions are compared.\r\n *\r\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\r\n * mappings with the same generated line and column, but different\r\n * source/name/original line and column the same. Useful when searching for a\r\n * mapping with a stubbed out mapping.\r\n */\r\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\r\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0 || onlyCompareGenerated) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\r\n\r\nfunction strcmp(aStr1, aStr2) {\r\n  if (aStr1 === aStr2) {\r\n    return 0;\r\n  }\r\n\r\n  if (aStr1 === null) {\r\n    return 1; // aStr2 !== null\r\n  }\r\n\r\n  if (aStr2 === null) {\r\n    return -1; // aStr1 !== null\r\n  }\r\n\r\n  if (aStr1 > aStr2) {\r\n    return 1;\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\n/**\r\n * Comparator between two mappings with inflated source and name strings where\r\n * the generated positions are compared.\r\n */\r\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\r\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = strcmp(mappingA.source, mappingB.source);\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalLine - mappingB.originalLine;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\r\n  if (cmp !== 0) {\r\n    return cmp;\r\n  }\r\n\r\n  return strcmp(mappingA.name, mappingB.name);\r\n}\r\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\r\n\r\n/**\r\n * Strip any JSON XSSI avoidance prefix from the string (as documented\r\n * in the source maps specification), and then parse the string as\r\n * JSON.\r\n */\r\nfunction parseSourceMapInput(str) {\r\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\r\n}\r\nexports.parseSourceMapInput = parseSourceMapInput;\r\n\r\n/**\r\n * Compute the URL of a source given the the source root, the source's\r\n * URL, and the source map's URL.\r\n */\r\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\r\n  sourceURL = sourceURL || '';\r\n\r\n  if (sourceRoot) {\r\n    // This follows what Chrome does.\r\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\r\n      sourceRoot += '/';\r\n    }\r\n    // The spec says:\r\n    //   Line 4: An optional source root, useful for relocating source\r\n    //   files on a server or removing repeated values in the\r\n    //   sources entry.  This value is prepended to the individual\r\n    //   entries in the source field.\r\n    sourceURL = sourceRoot + sourceURL;\r\n  }\r\n\r\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\r\n  // a parameter.  This mode is still somewhat supported, which is why\r\n  // this code block is conditional.  However, it's preferable to pass\r\n  // the source map URL to SourceMapConsumer, so that this function\r\n  // can implement the source URL resolution algorithm as outlined in\r\n  // the spec.  This block is basically the equivalent of:\r\n  //    new URL(sourceURL, sourceMapURL).toString()\r\n  // ... except it avoids using URL, which wasn't available in the\r\n  // older releases of node still supported by this library.\r\n  //\r\n  // The spec says:\r\n  //   If the sources are not absolute URLs after prepending of the\r\n  //   sourceRoot, the sources are resolved relative to the\r\n  //   SourceMap (like resolving script src in a html document).\r\n  if (sourceMapURL) {\r\n    var parsed = urlParse(sourceMapURL);\r\n    if (!parsed) {\r\n      throw new Error(\"sourceMapURL could not be parsed\");\r\n    }\r\n    if (parsed.path) {\r\n      // Strip the last path component, but keep the \"/\".\r\n      var index = parsed.path.lastIndexOf('/');\r\n      if (index >= 0) {\r\n        parsed.path = parsed.path.substring(0, index + 1);\r\n      }\r\n    }\r\n    sourceURL = join(urlGenerate(parsed), sourceURL);\r\n  }\r\n\r\n  return normalize(sourceURL);\r\n}\r\nexports.computeSourceURL = computeSourceURL;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require('./util');\r\nvar has = Object.prototype.hasOwnProperty;\r\nvar hasNativeMap = typeof Map !== \"undefined\";\r\n\r\n/**\r\n * A data structure which is a combination of an array and a set. Adding a new\r\n * member is O(1), testing for membership is O(1), and finding the index of an\r\n * element is O(1). Removing elements from the set is not supported. Only\r\n * strings are supported for membership.\r\n */\r\nfunction ArraySet() {\r\n  this._array = [];\r\n  this._set = hasNativeMap ? new Map() : Object.create(null);\r\n}\r\n\r\n/**\r\n * Static method for creating ArraySet instances from an existing array.\r\n */\r\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\r\n  var set = new ArraySet();\r\n  for (var i = 0, len = aArray.length; i < len; i++) {\r\n    set.add(aArray[i], aAllowDuplicates);\r\n  }\r\n  return set;\r\n};\r\n\r\n/**\r\n * Return how many unique items are in this ArraySet. If duplicates have been\r\n * added, than those do not count towards the size.\r\n *\r\n * @returns Number\r\n */\r\nArraySet.prototype.size = function ArraySet_size() {\r\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\r\n};\r\n\r\n/**\r\n * Add the given string to this set.\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\r\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\r\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\r\n  var idx = this._array.length;\r\n  if (!isDuplicate || aAllowDuplicates) {\r\n    this._array.push(aStr);\r\n  }\r\n  if (!isDuplicate) {\r\n    if (hasNativeMap) {\r\n      this._set.set(aStr, idx);\r\n    } else {\r\n      this._set[sStr] = idx;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Is the given string a member of this set?\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.has = function ArraySet_has(aStr) {\r\n  if (hasNativeMap) {\r\n    return this._set.has(aStr);\r\n  } else {\r\n    var sStr = util.toSetString(aStr);\r\n    return has.call(this._set, sStr);\r\n  }\r\n};\r\n\r\n/**\r\n * What is the index of the given string in the array?\r\n *\r\n * @param String aStr\r\n */\r\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\r\n  if (hasNativeMap) {\r\n    var idx = this._set.get(aStr);\r\n    if (idx >= 0) {\r\n        return idx;\r\n    }\r\n  } else {\r\n    var sStr = util.toSetString(aStr);\r\n    if (has.call(this._set, sStr)) {\r\n      return this._set[sStr];\r\n    }\r\n  }\r\n\r\n  throw new Error('\"' + aStr + '\" is not in the set.');\r\n};\r\n\r\n/**\r\n * What is the element at the given index?\r\n *\r\n * @param Number aIdx\r\n */\r\nArraySet.prototype.at = function ArraySet_at(aIdx) {\r\n  if (aIdx >= 0 && aIdx < this._array.length) {\r\n    return this._array[aIdx];\r\n  }\r\n  throw new Error('No element indexed by ' + aIdx);\r\n};\r\n\r\n/**\r\n * Returns the array representation of this set (which has the proper indices\r\n * indicated by indexOf). Note that this is a copy of the internal array used\r\n * for storing the members so that no one can mess with internal state.\r\n */\r\nArraySet.prototype.toArray = function ArraySet_toArray() {\r\n  return this._array.slice();\r\n};\r\n\r\nexports.ArraySet = ArraySet;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n *\r\n * Based on the Base 64 VLQ implementation in Closure Compiler:\r\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\r\n *\r\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *  * Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above\r\n *    copyright notice, this list of conditions and the following\r\n *    disclaimer in the documentation and/or other materials provided\r\n *    with the distribution.\r\n *  * Neither the name of Google Inc. nor the names of its\r\n *    contributors may be used to endorse or promote products derived\r\n *    from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nvar base64 = require('./base64');\r\n\r\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\r\n// length quantities we use in the source map spec, the first bit is the sign,\r\n// the next four bits are the actual value, and the 6th bit is the\r\n// continuation bit. The continuation bit tells us whether there are more\r\n// digits in this value following this digit.\r\n//\r\n//   Continuation\r\n//   |    Sign\r\n//   |    |\r\n//   V    V\r\n//   101011\r\n\r\nvar VLQ_BASE_SHIFT = 5;\r\n\r\n// binary: 100000\r\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\r\n\r\n// binary: 011111\r\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\r\n\r\n// binary: 100000\r\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\r\n\r\n/**\r\n * Converts from a two-complement value to a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\r\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\r\n */\r\nfunction toVLQSigned(aValue) {\r\n  return aValue < 0\r\n    ? ((-aValue) << 1) + 1\r\n    : (aValue << 1) + 0;\r\n}\r\n\r\n/**\r\n * Converts to a two-complement value from a value where the sign bit is\r\n * placed in the least significant bit.  For example, as decimals:\r\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\r\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\r\n */\r\nfunction fromVLQSigned(aValue) {\r\n  var isNegative = (aValue & 1) === 1;\r\n  var shifted = aValue >> 1;\r\n  return isNegative\r\n    ? -shifted\r\n    : shifted;\r\n}\r\n\r\n/**\r\n * Returns the base 64 VLQ encoded value.\r\n */\r\nexports.encode = function base64VLQ_encode(aValue) {\r\n  var encoded = \"\";\r\n  var digit;\r\n\r\n  var vlq = toVLQSigned(aValue);\r\n\r\n  do {\r\n    digit = vlq & VLQ_BASE_MASK;\r\n    vlq >>>= VLQ_BASE_SHIFT;\r\n    if (vlq > 0) {\r\n      // There are still more digits in this value, so we must make sure the\r\n      // continuation bit is marked.\r\n      digit |= VLQ_CONTINUATION_BIT;\r\n    }\r\n    encoded += base64.encode(digit);\r\n  } while (vlq > 0);\r\n\r\n  return encoded;\r\n};\r\n\r\n/**\r\n * Decodes the next base 64 VLQ value from the given string and returns the\r\n * value and the rest of the string via the out parameter.\r\n */\r\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\r\n  var strLen = aStr.length;\r\n  var result = 0;\r\n  var shift = 0;\r\n  var continuation, digit;\r\n\r\n  do {\r\n    if (aIndex >= strLen) {\r\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\r\n    }\r\n\r\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\r\n    if (digit === -1) {\r\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\r\n    }\r\n\r\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\r\n    digit &= VLQ_BASE_MASK;\r\n    result = result + (digit << shift);\r\n    shift += VLQ_BASE_SHIFT;\r\n  } while (continuation);\r\n\r\n  aOutParam.value = fromVLQSigned(result);\r\n  aOutParam.rest = aIndex;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar base64VLQ = require('./base64-vlq');\r\nvar util = require('./util');\r\nvar ArraySet = require('./array-set').ArraySet;\r\nvar MappingList = require('./mapping-list').MappingList;\r\n\r\n/**\r\n * An instance of the SourceMapGenerator represents a source map which is\r\n * being built incrementally. You may pass an object with the following\r\n * properties:\r\n *\r\n *   - file: The filename of the generated source.\r\n *   - sourceRoot: A root for all relative URLs in this source map.\r\n */\r\nfunction SourceMapGenerator(aArgs) {\r\n  if (!aArgs) {\r\n    aArgs = {};\r\n  }\r\n  this._file = util.getArg(aArgs, 'file', null);\r\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\r\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\r\n  this._sources = new ArraySet();\r\n  this._names = new ArraySet();\r\n  this._mappings = new MappingList();\r\n  this._sourcesContents = null;\r\n}\r\n\r\nSourceMapGenerator.prototype._version = 3;\r\n\r\n/**\r\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\r\n *\r\n * @param aSourceMapConsumer The SourceMap.\r\n */\r\nSourceMapGenerator.fromSourceMap =\r\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\r\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\r\n    var generator = new SourceMapGenerator({\r\n      file: aSourceMapConsumer.file,\r\n      sourceRoot: sourceRoot\r\n    });\r\n    aSourceMapConsumer.eachMapping(function (mapping) {\r\n      var newMapping = {\r\n        generated: {\r\n          line: mapping.generatedLine,\r\n          column: mapping.generatedColumn\r\n        }\r\n      };\r\n\r\n      if (mapping.source != null) {\r\n        newMapping.source = mapping.source;\r\n        if (sourceRoot != null) {\r\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\r\n        }\r\n\r\n        newMapping.original = {\r\n          line: mapping.originalLine,\r\n          column: mapping.originalColumn\r\n        };\r\n\r\n        if (mapping.name != null) {\r\n          newMapping.name = mapping.name;\r\n        }\r\n      }\r\n\r\n      generator.addMapping(newMapping);\r\n    });\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var sourceRelative = sourceFile;\r\n      if (sourceRoot !== null) {\r\n        sourceRelative = util.relative(sourceRoot, sourceFile);\r\n      }\r\n\r\n      if (!generator._sources.has(sourceRelative)) {\r\n        generator._sources.add(sourceRelative);\r\n      }\r\n\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        generator.setSourceContent(sourceFile, content);\r\n      }\r\n    });\r\n    return generator;\r\n  };\r\n\r\n/**\r\n * Add a single mapping from original source line and column to the generated\r\n * source's line and column for this source map being created. The mapping\r\n * object should have the following properties:\r\n *\r\n *   - generated: An object with the generated line and column positions.\r\n *   - original: An object with the original line and column positions.\r\n *   - source: The original source file (relative to the sourceRoot).\r\n *   - name: An optional original token name for this mapping.\r\n */\r\nSourceMapGenerator.prototype.addMapping =\r\n  function SourceMapGenerator_addMapping(aArgs) {\r\n    var generated = util.getArg(aArgs, 'generated');\r\n    var original = util.getArg(aArgs, 'original', null);\r\n    var source = util.getArg(aArgs, 'source', null);\r\n    var name = util.getArg(aArgs, 'name', null);\r\n\r\n    if (!this._skipValidation) {\r\n      this._validateMapping(generated, original, source, name);\r\n    }\r\n\r\n    if (source != null) {\r\n      source = String(source);\r\n      if (!this._sources.has(source)) {\r\n        this._sources.add(source);\r\n      }\r\n    }\r\n\r\n    if (name != null) {\r\n      name = String(name);\r\n      if (!this._names.has(name)) {\r\n        this._names.add(name);\r\n      }\r\n    }\r\n\r\n    this._mappings.add({\r\n      generatedLine: generated.line,\r\n      generatedColumn: generated.column,\r\n      originalLine: original != null && original.line,\r\n      originalColumn: original != null && original.column,\r\n      source: source,\r\n      name: name\r\n    });\r\n  };\r\n\r\n/**\r\n * Set the source content for a source file.\r\n */\r\nSourceMapGenerator.prototype.setSourceContent =\r\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\r\n    var source = aSourceFile;\r\n    if (this._sourceRoot != null) {\r\n      source = util.relative(this._sourceRoot, source);\r\n    }\r\n\r\n    if (aSourceContent != null) {\r\n      // Add the source content to the _sourcesContents map.\r\n      // Create a new _sourcesContents map if the property is null.\r\n      if (!this._sourcesContents) {\r\n        this._sourcesContents = Object.create(null);\r\n      }\r\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\r\n    } else if (this._sourcesContents) {\r\n      // Remove the source file from the _sourcesContents map.\r\n      // If the _sourcesContents map is empty, set the property to null.\r\n      delete this._sourcesContents[util.toSetString(source)];\r\n      if (Object.keys(this._sourcesContents).length === 0) {\r\n        this._sourcesContents = null;\r\n      }\r\n    }\r\n  };\r\n\r\n/**\r\n * Applies the mappings of a sub-source-map for a specific source file to the\r\n * source map being generated. Each mapping to the supplied source file is\r\n * rewritten using the supplied source map. Note: The resolution for the\r\n * resulting mappings is the minimium of this map and the supplied map.\r\n *\r\n * @param aSourceMapConsumer The source map to be applied.\r\n * @param aSourceFile Optional. The filename of the source file.\r\n *        If omitted, SourceMapConsumer's file property will be used.\r\n * @param aSourceMapPath Optional. The dirname of the path to the source map\r\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\r\n *        This parameter is needed when the two source maps aren't in the same\r\n *        directory, and the source map to be applied contains relative source\r\n *        paths. If so, those relative source paths need to be rewritten\r\n *        relative to the SourceMapGenerator.\r\n */\r\nSourceMapGenerator.prototype.applySourceMap =\r\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\r\n    var sourceFile = aSourceFile;\r\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\r\n    if (aSourceFile == null) {\r\n      if (aSourceMapConsumer.file == null) {\r\n        throw new Error(\r\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\r\n          'or the source map\\'s \"file\" property. Both were omitted.'\r\n        );\r\n      }\r\n      sourceFile = aSourceMapConsumer.file;\r\n    }\r\n    var sourceRoot = this._sourceRoot;\r\n    // Make \"sourceFile\" relative if an absolute Url is passed.\r\n    if (sourceRoot != null) {\r\n      sourceFile = util.relative(sourceRoot, sourceFile);\r\n    }\r\n    // Applying the SourceMap can add and remove items from the sources and\r\n    // the names array.\r\n    var newSources = this._mappings.toArray().length > 0\r\n      ? new ArraySet()\r\n      : this._sources;\r\n    var newNames = new ArraySet();\r\n\r\n    // Find mappings for the \"sourceFile\"\r\n    this._mappings.unsortedForEach(function (mapping) {\r\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\r\n        // Check if it can be mapped by the source map, then update the mapping.\r\n        var original = aSourceMapConsumer.originalPositionFor({\r\n          line: mapping.originalLine,\r\n          column: mapping.originalColumn\r\n        });\r\n        if (original.source != null) {\r\n          // Copy mapping\r\n          mapping.source = original.source;\r\n          if (aSourceMapPath != null) {\r\n            mapping.source = util.join(aSourceMapPath, mapping.source)\r\n          }\r\n          if (sourceRoot != null) {\r\n            mapping.source = util.relative(sourceRoot, mapping.source);\r\n          }\r\n          mapping.originalLine = original.line;\r\n          mapping.originalColumn = original.column;\r\n          if (original.name != null) {\r\n            mapping.name = original.name;\r\n          }\r\n        }\r\n      }\r\n\r\n      var source = mapping.source;\r\n      if (source != null && !newSources.has(source)) {\r\n        newSources.add(source);\r\n      }\r\n\r\n      var name = mapping.name;\r\n      if (name != null && !newNames.has(name)) {\r\n        newNames.add(name);\r\n      }\r\n\r\n    }, this);\r\n    this._sources = newSources;\r\n    this._names = newNames;\r\n\r\n    // Copy sourcesContents of applied map.\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        if (aSourceMapPath != null) {\r\n          sourceFile = util.join(aSourceMapPath, sourceFile);\r\n        }\r\n        if (sourceRoot != null) {\r\n          sourceFile = util.relative(sourceRoot, sourceFile);\r\n        }\r\n        this.setSourceContent(sourceFile, content);\r\n      }\r\n    }, this);\r\n  };\r\n\r\n/**\r\n * A mapping can have one of the three levels of data:\r\n *\r\n *   1. Just the generated position.\r\n *   2. The Generated position, original position, and original source.\r\n *   3. Generated and original position, original source, as well as a name\r\n *      token.\r\n *\r\n * To maintain consistency, we validate that any new mapping being added falls\r\n * in to one of these categories.\r\n */\r\nSourceMapGenerator.prototype._validateMapping =\r\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\r\n                                              aName) {\r\n    // When aOriginal is truthy but has empty values for .line and .column,\r\n    // it is most likely a programmer error. In this case we throw a very\r\n    // specific error message to try to guide them the right way.\r\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\r\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\r\n        throw new Error(\r\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\r\n            'the original mapping entirely and only map the generated position. If so, pass ' +\r\n            'null for the original mapping instead of an object with empty or null values.'\r\n        );\r\n    }\r\n\r\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\r\n        && aGenerated.line > 0 && aGenerated.column >= 0\r\n        && !aOriginal && !aSource && !aName) {\r\n      // Case 1.\r\n      return;\r\n    }\r\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\r\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\r\n             && aGenerated.line > 0 && aGenerated.column >= 0\r\n             && aOriginal.line > 0 && aOriginal.column >= 0\r\n             && aSource) {\r\n      // Cases 2 and 3.\r\n      return;\r\n    }\r\n    else {\r\n      throw new Error('Invalid mapping: ' + JSON.stringify({\r\n        generated: aGenerated,\r\n        source: aSource,\r\n        original: aOriginal,\r\n        name: aName\r\n      }));\r\n    }\r\n  };\r\n\r\n/**\r\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\r\n * specified by the source map format.\r\n */\r\nSourceMapGenerator.prototype._serializeMappings =\r\n  function SourceMapGenerator_serializeMappings() {\r\n    var previousGeneratedColumn = 0;\r\n    var previousGeneratedLine = 1;\r\n    var previousOriginalColumn = 0;\r\n    var previousOriginalLine = 0;\r\n    var previousName = 0;\r\n    var previousSource = 0;\r\n    var result = '';\r\n    var next;\r\n    var mapping;\r\n    var nameIdx;\r\n    var sourceIdx;\r\n\r\n    var mappings = this._mappings.toArray();\r\n    for (var i = 0, len = mappings.length; i < len; i++) {\r\n      mapping = mappings[i];\r\n      next = ''\r\n\r\n      if (mapping.generatedLine !== previousGeneratedLine) {\r\n        previousGeneratedColumn = 0;\r\n        while (mapping.generatedLine !== previousGeneratedLine) {\r\n          next += ';';\r\n          previousGeneratedLine++;\r\n        }\r\n      }\r\n      else {\r\n        if (i > 0) {\r\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\r\n            continue;\r\n          }\r\n          next += ',';\r\n        }\r\n      }\r\n\r\n      next += base64VLQ.encode(mapping.generatedColumn\r\n                                 - previousGeneratedColumn);\r\n      previousGeneratedColumn = mapping.generatedColumn;\r\n\r\n      if (mapping.source != null) {\r\n        sourceIdx = this._sources.indexOf(mapping.source);\r\n        next += base64VLQ.encode(sourceIdx - previousSource);\r\n        previousSource = sourceIdx;\r\n\r\n        // lines are stored 0-based in SourceMap spec version 3\r\n        next += base64VLQ.encode(mapping.originalLine - 1\r\n                                   - previousOriginalLine);\r\n        previousOriginalLine = mapping.originalLine - 1;\r\n\r\n        next += base64VLQ.encode(mapping.originalColumn\r\n                                   - previousOriginalColumn);\r\n        previousOriginalColumn = mapping.originalColumn;\r\n\r\n        if (mapping.name != null) {\r\n          nameIdx = this._names.indexOf(mapping.name);\r\n          next += base64VLQ.encode(nameIdx - previousName);\r\n          previousName = nameIdx;\r\n        }\r\n      }\r\n\r\n      result += next;\r\n    }\r\n\r\n    return result;\r\n  };\r\n\r\nSourceMapGenerator.prototype._generateSourcesContent =\r\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\r\n    return aSources.map(function (source) {\r\n      if (!this._sourcesContents) {\r\n        return null;\r\n      }\r\n      if (aSourceRoot != null) {\r\n        source = util.relative(aSourceRoot, source);\r\n      }\r\n      var key = util.toSetString(source);\r\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\r\n        ? this._sourcesContents[key]\r\n        : null;\r\n    }, this);\r\n  };\r\n\r\n/**\r\n * Externalize the source map.\r\n */\r\nSourceMapGenerator.prototype.toJSON =\r\n  function SourceMapGenerator_toJSON() {\r\n    var map = {\r\n      version: this._version,\r\n      sources: this._sources.toArray(),\r\n      names: this._names.toArray(),\r\n      mappings: this._serializeMappings()\r\n    };\r\n    if (this._file != null) {\r\n      map.file = this._file;\r\n    }\r\n    if (this._sourceRoot != null) {\r\n      map.sourceRoot = this._sourceRoot;\r\n    }\r\n    if (this._sourcesContents) {\r\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\r\n    }\r\n\r\n    return map;\r\n  };\r\n\r\n/**\r\n * Render the source map being generated to a string.\r\n */\r\nSourceMapGenerator.prototype.toString =\r\n  function SourceMapGenerator_toString() {\r\n    return JSON.stringify(this.toJSON());\r\n  };\r\n\r\nexports.SourceMapGenerator = SourceMapGenerator;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\r\nvar util = require('./util');\r\n\r\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\r\n// operating systems these days (capturing the result).\r\nvar REGEX_NEWLINE = /(\\r?\\n)/;\r\n\r\n// Newline character code for charCodeAt() comparisons\r\nvar NEWLINE_CODE = 10;\r\n\r\n// Private symbol for identifying `SourceNode`s when multiple versions of\r\n// the source-map library are loaded. This MUST NOT CHANGE across\r\n// versions!\r\nvar isSourceNode = \"$$$isSourceNode$$$\";\r\n\r\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\r\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\r\n  this.children = [];\r\n  this.sourceContents = {};\r\n  this.line = aLine == null ? null : aLine;\r\n  this.column = aColumn == null ? null : aColumn;\r\n  this.source = aSource == null ? null : aSource;\r\n  this.name = aName == null ? null : aName;\r\n  this[isSourceNode] = true;\r\n  if (aChunks != null) this.add(aChunks);\r\n}\r\n\r\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\r\nSourceNode.fromStringWithSourceMap =\r\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\r\n    // The SourceNode we want to fill with the generated code\r\n    // and the SourceMap\r\n    var node = new SourceNode();\r\n\r\n    // All even indices of this array are one line of the generated code,\r\n    // while all odd indices are the newlines between two adjacent lines\r\n    // (since `REGEX_NEWLINE` captures its match).\r\n    // Processed fragments are accessed by calling `shiftNextLine`.\r\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\r\n    var remainingLinesIndex = 0;\r\n    var shiftNextLine = function() {\r\n      var lineContents = getNextLine();\r\n      // The last line of a file might not have a newline.\r\n      var newLine = getNextLine() || \"\";\r\n      return lineContents + newLine;\r\n\r\n      function getNextLine() {\r\n        return remainingLinesIndex < remainingLines.length ?\r\n            remainingLines[remainingLinesIndex++] : undefined;\r\n      }\r\n    };\r\n\r\n    // We need to remember the position of \"remainingLines\"\r\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\r\n\r\n    // The generate SourceNodes we need a code range.\r\n    // To extract it current and last mapping is used.\r\n    // Here we store the last mapping.\r\n    var lastMapping = null;\r\n\r\n    aSourceMapConsumer.eachMapping(function (mapping) {\r\n      if (lastMapping !== null) {\r\n        // We add the code from \"lastMapping\" to \"mapping\":\r\n        // First check if there is a new line in between.\r\n        if (lastGeneratedLine < mapping.generatedLine) {\r\n          // Associate first line with \"lastMapping\"\r\n          addMappingWithCode(lastMapping, shiftNextLine());\r\n          lastGeneratedLine++;\r\n          lastGeneratedColumn = 0;\r\n          // The remaining code is added without mapping\r\n        } else {\r\n          // There is no new line in between.\r\n          // Associate the code between \"lastGeneratedColumn\" and\r\n          // \"mapping.generatedColumn\" with \"lastMapping\"\r\n          var nextLine = remainingLines[remainingLinesIndex] || '';\r\n          var code = nextLine.substr(0, mapping.generatedColumn -\r\n                                        lastGeneratedColumn);\r\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\r\n                                              lastGeneratedColumn);\r\n          lastGeneratedColumn = mapping.generatedColumn;\r\n          addMappingWithCode(lastMapping, code);\r\n          // No more remaining code, continue\r\n          lastMapping = mapping;\r\n          return;\r\n        }\r\n      }\r\n      // We add the generated code until the first mapping\r\n      // to the SourceNode without any mapping.\r\n      // Each line is added as separate string.\r\n      while (lastGeneratedLine < mapping.generatedLine) {\r\n        node.add(shiftNextLine());\r\n        lastGeneratedLine++;\r\n      }\r\n      if (lastGeneratedColumn < mapping.generatedColumn) {\r\n        var nextLine = remainingLines[remainingLinesIndex] || '';\r\n        node.add(nextLine.substr(0, mapping.generatedColumn));\r\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\r\n        lastGeneratedColumn = mapping.generatedColumn;\r\n      }\r\n      lastMapping = mapping;\r\n    }, this);\r\n    // We have processed all mappings.\r\n    if (remainingLinesIndex < remainingLines.length) {\r\n      if (lastMapping) {\r\n        // Associate the remaining code in the current line with \"lastMapping\"\r\n        addMappingWithCode(lastMapping, shiftNextLine());\r\n      }\r\n      // and add the remaining lines without any mapping\r\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\r\n    }\r\n\r\n    // Copy sourcesContent into SourceNode\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        if (aRelativePath != null) {\r\n          sourceFile = util.join(aRelativePath, sourceFile);\r\n        }\r\n        node.setSourceContent(sourceFile, content);\r\n      }\r\n    });\r\n\r\n    return node;\r\n\r\n    function addMappingWithCode(mapping, code) {\r\n      if (mapping === null || mapping.source === undefined) {\r\n        node.add(code);\r\n      } else {\r\n        var source = aRelativePath && mapping.source\r\n          ? util.join(aRelativePath, mapping.source)\r\n          : mapping.source;\r\n        node.add(new SourceNode(mapping.originalLine,\r\n                                mapping.originalColumn,\r\n                                source,\r\n                                code,\r\n                                mapping.name));\r\n      }\r\n    }\r\n  };\r\n\r\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    aChunk.forEach(function (chunk) {\r\n      this.add(chunk);\r\n    }, this);\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    if (aChunk) {\r\n      this.children.push(aChunk);\r\n    }\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    for (var i = aChunk.length-1; i >= 0; i--) {\r\n      this.prepend(aChunk[i]);\r\n    }\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    this.children.unshift(aChunk);\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\r\n  var chunk;\r\n  for (var i = 0, len = this.children.length; i < len; i++) {\r\n    chunk = this.children[i];\r\n    if (chunk[isSourceNode]) {\r\n      chunk.walk(aFn);\r\n    }\r\n    else {\r\n      if (chunk !== '') {\r\n        aFn(chunk, { source: this.source,\r\n                     line: this.line,\r\n                     column: this.column,\r\n                     name: this.name });\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\r\nSourceNode.prototype.join = function SourceNode_join(aSep) {\r\n  var newChildren;\r\n  var i;\r\n  var len = this.children.length;\r\n  if (len > 0) {\r\n    newChildren = [];\r\n    for (i = 0; i < len-1; i++) {\r\n      newChildren.push(this.children[i]);\r\n      newChildren.push(aSep);\r\n    }\r\n    newChildren.push(this.children[i]);\r\n    this.children = newChildren;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\r\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\r\n  var lastChild = this.children[this.children.length - 1];\r\n  if (lastChild[isSourceNode]) {\r\n    lastChild.replaceRight(aPattern, aReplacement);\r\n  }\r\n  else if (typeof lastChild === 'string') {\r\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\r\n  }\r\n  else {\r\n    this.children.push(''.replace(aPattern, aReplacement));\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\r\nSourceNode.prototype.setSourceContent =\r\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\r\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\r\n  };\r\n\r\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walkSourceContents =\r\n  function SourceNode_walkSourceContents(aFn) {\r\n    for (var i = 0, len = this.children.length; i < len; i++) {\r\n      if (this.children[i][isSourceNode]) {\r\n        this.children[i].walkSourceContents(aFn);\r\n      }\r\n    }\r\n\r\n    var sources = Object.keys(this.sourceContents);\r\n    for (var i = 0, len = sources.length; i < len; i++) {\r\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\r\n    }\r\n  };\r\n\r\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\r\nSourceNode.prototype.toString = function SourceNode_toString() {\r\n  var str = \"\";\r\n  this.walk(function (chunk) {\r\n    str += chunk;\r\n  });\r\n  return str;\r\n};\r\n\r\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\r\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\r\n  var generated = {\r\n    code: \"\",\r\n    line: 1,\r\n    column: 0\r\n  };\r\n  var map = new SourceMapGenerator(aArgs);\r\n  var sourceMappingActive = false;\r\n  var lastOriginalSource = null;\r\n  var lastOriginalLine = null;\r\n  var lastOriginalColumn = null;\r\n  var lastOriginalName = null;\r\n  this.walk(function (chunk, original) {\r\n    generated.code += chunk;\r\n    if (original.source !== null\r\n        && original.line !== null\r\n        && original.column !== null) {\r\n      if(lastOriginalSource !== original.source\r\n         || lastOriginalLine !== original.line\r\n         || lastOriginalColumn !== original.column\r\n         || lastOriginalName !== original.name) {\r\n        map.addMapping({\r\n          source: original.source,\r\n          original: {\r\n            line: original.line,\r\n            column: original.column\r\n          },\r\n          generated: {\r\n            line: generated.line,\r\n            column: generated.column\r\n          },\r\n          name: original.name\r\n        });\r\n      }\r\n      lastOriginalSource = original.source;\r\n      lastOriginalLine = original.line;\r\n      lastOriginalColumn = original.column;\r\n      lastOriginalName = original.name;\r\n      sourceMappingActive = true;\r\n    } else if (sourceMappingActive) {\r\n      map.addMapping({\r\n        generated: {\r\n          line: generated.line,\r\n          column: generated.column\r\n        }\r\n      });\r\n      lastOriginalSource = null;\r\n      sourceMappingActive = false;\r\n    }\r\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\r\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\r\n        generated.line++;\r\n        generated.column = 0;\r\n        // Mappings end at eol\r\n        if (idx + 1 === length) {\r\n          lastOriginalSource = null;\r\n          sourceMappingActive = false;\r\n        } else if (sourceMappingActive) {\r\n          map.addMapping({\r\n            source: original.source,\r\n            original: {\r\n              line: original.line,\r\n              column: original.column\r\n            },\r\n            generated: {\r\n              line: generated.line,\r\n              column: generated.column\r\n            },\r\n            name: original.name\r\n          });\r\n        }\r\n      } else {\r\n        generated.column++;\r\n      }\r\n    }\r\n  });\r\n  this.walkSourceContents(function (sourceFile, sourceContent) {\r\n    map.setSourceContent(sourceFile, sourceContent);\r\n  });\r\n\r\n  return { code: generated.code, map: map };\r\n};\r\n\r\nexports.SourceNode = SourceNode;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\n// It turns out that some (most?) JavaScript engines don't self-host\r\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\r\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\r\n// custom comparator function, calling back and forth between the VM's C++ and\r\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\r\n// worse generated code for the comparator function than would be optimal. In\r\n// fact, when sorting with a comparator, these costs outweigh the benefits of\r\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\r\n// a ~3500ms mean speed-up in `bench/bench.html`.\r\n\r\n// Capture Math.random() now, to avoid problems in case a test mocks it later.\r\n// If Math.random() is mocked to return a constant value, quickSort may become\r\n// O(n^2) when invoked on already-sorted data.\r\nvar random = Math.random;\r\n\r\n/**\r\n * Swap the elements indexed by `x` and `y` in the array `ary`.\r\n *\r\n * @param {Array} ary\r\n *        The array.\r\n * @param {Number} x\r\n *        The index of the first item.\r\n * @param {Number} y\r\n *        The index of the second item.\r\n */\r\nfunction swap(ary, x, y) {\r\n  var temp = ary[x];\r\n  ary[x] = ary[y];\r\n  ary[y] = temp;\r\n}\r\n\r\n/**\r\n * Returns a random integer within the range `low .. high` inclusive.\r\n *\r\n * @param {Number} low\r\n *        The lower bound on the range.\r\n * @param {Number} high\r\n *        The upper bound on the range.\r\n */\r\nfunction randomIntInRange(low, high) {\r\n  return Math.round(low + (random() * (high - low)));\r\n}\r\n\r\n/**\r\n * The Quick Sort algorithm.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n * @param {Number} p\r\n *        Start index of the array\r\n * @param {Number} r\r\n *        End index of the array\r\n */\r\nfunction doQuickSort(ary, comparator, p, r) {\r\n  // If our lower bound is less than our upper bound, we (1) partition the\r\n  // array into two pieces and (2) recurse on each half. If it is not, this is\r\n  // the empty array and our base case.\r\n\r\n  if (p < r) {\r\n    // (1) Partitioning.\r\n    //\r\n    // The partitioning chooses a pivot between `p` and `r` and moves all\r\n    // elements that are less than or equal to the pivot to the before it, and\r\n    // all the elements that are greater than it after it. The effect is that\r\n    // once partition is done, the pivot is in the exact place it will be when\r\n    // the array is put in sorted order, and it will not need to be moved\r\n    // again. This runs in O(n log n) time.\r\n\r\n    // Always choose a random pivot so that an input array which is reverse\r\n    // sorted does not cause O(n^2) running time.\r\n    var pivotIndex = randomIntInRange(p, r);\r\n    var i = p - 1;\r\n\r\n    swap(ary, pivotIndex, r);\r\n    var pivot = ary[r];\r\n\r\n    // Immediately after `j` is incremented in this loop, the following hold\r\n    // true:\r\n    //\r\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\r\n    //\r\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\r\n    for (var j = p; j < r; j++) {\r\n      if (comparator(ary[j], pivot) <= 0) {\r\n        i += 1;\r\n        swap(ary, i, j);\r\n      }\r\n    }\r\n\r\n    swap(ary, i + 1, j);\r\n    var q = i + 1;\r\n\r\n    // (2) Recurse on each half.\r\n\r\n    doQuickSort(ary, comparator, p, q - 1);\r\n    doQuickSort(ary, comparator, q + 1, r);\r\n  }\r\n}\r\n\r\n/**\r\n * Sort the given array in-place with the given comparator function.\r\n *\r\n * @param {Array} ary\r\n *        An array to sort.\r\n * @param {function} comparator\r\n *        Function to use to compare two items.\r\n */\r\nexports.quickSort = function (ary, comparator) {\r\n  doQuickSort(ary, comparator, 0, ary.length - 1);\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nexports.GREATEST_LOWER_BOUND = 1;\r\nexports.LEAST_UPPER_BOUND = 2;\r\n\r\n/**\r\n * Recursive implementation of binary search.\r\n *\r\n * @param aLow Indices here and lower do not contain the needle.\r\n * @param aHigh Indices here and higher do not contain the needle.\r\n * @param aNeedle The element being searched for.\r\n * @param aHaystack The non-empty array being searched.\r\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n */\r\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\r\n  // This function terminates when one of the following is true:\r\n  //\r\n  //   1. We find the exact element we are looking for.\r\n  //\r\n  //   2. We did not find the exact element, but we can return the index of\r\n  //      the next-closest element.\r\n  //\r\n  //   3. We did not find the exact element, and there is no next-closest\r\n  //      element than the one we are searching for, so we return -1.\r\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\r\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\r\n  if (cmp === 0) {\r\n    // Found the element we are looking for.\r\n    return mid;\r\n  }\r\n  else if (cmp > 0) {\r\n    // Our needle is greater than aHaystack[mid].\r\n    if (aHigh - mid > 1) {\r\n      // The element is in the upper half.\r\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // The exact needle element was not found in this haystack. Determine if\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return aHigh < aHaystack.length ? aHigh : -1;\r\n    } else {\r\n      return mid;\r\n    }\r\n  }\r\n  else {\r\n    // Our needle is less than aHaystack[mid].\r\n    if (mid - aLow > 1) {\r\n      // The element is in the lower half.\r\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\r\n    }\r\n\r\n    // we are in termination case (3) or (2) and return the appropriate thing.\r\n    if (aBias == exports.LEAST_UPPER_BOUND) {\r\n      return mid;\r\n    } else {\r\n      return aLow < 0 ? -1 : aLow;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This is an implementation of binary search which will always try and return\r\n * the index of the closest element if there is no exact hit. This is because\r\n * mappings between original and generated line/col pairs are single points,\r\n * and there is an implicit region between each of them, so a miss just means\r\n * that you aren't on the very start of a region.\r\n *\r\n * @param aNeedle The element you are looking for.\r\n * @param aHaystack The array that is being searched.\r\n * @param aCompare A function which takes the needle and an element in the\r\n *     array and returns -1, 0, or 1 depending on whether the needle is less\r\n *     than, equal to, or greater than the element, respectively.\r\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\r\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\r\n */\r\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\r\n  if (aHaystack.length === 0) {\r\n    return -1;\r\n  }\r\n\r\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\r\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\r\n  if (index < 0) {\r\n    return -1;\r\n  }\r\n\r\n  // We have found either the exact element, or the next-closest element than\r\n  // the one we are searching for. However, there may be more than one such\r\n  // element. Make sure we always return the smallest of these.\r\n  while (index - 1 >= 0) {\r\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\r\n      break;\r\n    }\r\n    --index;\r\n  }\r\n\r\n  return index;\r\n};\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require('./util');\r\nvar binarySearch = require('./binary-search');\r\nvar ArraySet = require('./array-set').ArraySet;\r\nvar base64VLQ = require('./base64-vlq');\r\nvar quickSort = require('./quick-sort').quickSort;\r\n\r\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === 'string') {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  return sourceMap.sections != null\r\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\r\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\r\n}\r\n\r\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\r\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\r\n}\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nSourceMapConsumer.prototype._version = 3;\r\n\r\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\r\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\r\n// are lazily instantiated, accessed via the `_generatedMappings` and\r\n// `_originalMappings` getters respectively, and we only parse the mappings\r\n// and create these arrays once queried for a source location. We jump through\r\n// these hoops because there can be many thousands of mappings, and parsing\r\n// them is expensive, so we only want to do it if we must.\r\n//\r\n// Each object in the arrays is of the form:\r\n//\r\n//     {\r\n//       generatedLine: The line number in the generated code,\r\n//       generatedColumn: The column number in the generated code,\r\n//       source: The path to the original source file that generated this\r\n//               chunk of code,\r\n//       originalLine: The line number in the original source that\r\n//                     corresponds to this chunk of generated code,\r\n//       originalColumn: The column number in the original source that\r\n//                       corresponds to this chunk of generated code,\r\n//       name: The name of the original symbol which generated this chunk of\r\n//             code.\r\n//     }\r\n//\r\n// All properties except for `generatedLine` and `generatedColumn` can be\r\n// `null`.\r\n//\r\n// `_generatedMappings` is ordered by the generated positions.\r\n//\r\n// `_originalMappings` is ordered by the original positions.\r\n\r\nSourceMapConsumer.prototype.__generatedMappings = null;\r\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get: function () {\r\n    if (!this.__generatedMappings) {\r\n      this._parseMappings(this._mappings, this.sourceRoot);\r\n    }\r\n\r\n    return this.__generatedMappings;\r\n  }\r\n});\r\n\r\nSourceMapConsumer.prototype.__originalMappings = null;\r\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\r\n  configurable: true,\r\n  enumerable: true,\r\n  get: function () {\r\n    if (!this.__originalMappings) {\r\n      this._parseMappings(this._mappings, this.sourceRoot);\r\n    }\r\n\r\n    return this.__originalMappings;\r\n  }\r\n});\r\n\r\nSourceMapConsumer.prototype._charIsMappingSeparator =\r\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\r\n    var c = aStr.charAt(index);\r\n    return c === \";\" || c === \",\";\r\n  };\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nSourceMapConsumer.prototype._parseMappings =\r\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\r\n    throw new Error(\"Subclasses must implement _parseMappings\");\r\n  };\r\n\r\nSourceMapConsumer.GENERATED_ORDER = 1;\r\nSourceMapConsumer.ORIGINAL_ORDER = 2;\r\n\r\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\r\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\r\n\r\n/**\r\n * Iterate over each mapping between an original source/line/column and a\r\n * generated line/column in this source map.\r\n *\r\n * @param Function aCallback\r\n *        The function that is called with each mapping.\r\n * @param Object aContext\r\n *        Optional. If specified, this object will be the value of `this` every\r\n *        time that `aCallback` is called.\r\n * @param aOrder\r\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\r\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\r\n *        iterate over the mappings sorted by the generated file's line/column\r\n *        order or the original's source/line/column order, respectively. Defaults to\r\n *        `SourceMapConsumer.GENERATED_ORDER`.\r\n */\r\nSourceMapConsumer.prototype.eachMapping =\r\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\r\n    var context = aContext || null;\r\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\r\n\r\n    var mappings;\r\n    switch (order) {\r\n    case SourceMapConsumer.GENERATED_ORDER:\r\n      mappings = this._generatedMappings;\r\n      break;\r\n    case SourceMapConsumer.ORIGINAL_ORDER:\r\n      mappings = this._originalMappings;\r\n      break;\r\n    default:\r\n      throw new Error(\"Unknown order of iteration.\");\r\n    }\r\n\r\n    var sourceRoot = this.sourceRoot;\r\n    mappings.map(function (mapping) {\r\n      var source = null;\r\n      if(mapping.source !== null) {\r\n        source = this._sources.at(mapping.source);\r\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\r\n      }\r\n      return {\r\n        source: source,\r\n        generatedLine: mapping.generatedLine,\r\n        generatedColumn: mapping.generatedColumn,\r\n        originalLine: mapping.originalLine,\r\n        originalColumn: mapping.originalColumn,\r\n        name: mapping.name === null ? null : this._names.at(mapping.name)\r\n      };\r\n    }, this).forEach(aCallback, context);\r\n  };\r\n\r\n/**\r\n * Returns all generated line and column information for the original source,\r\n * line, and column provided. If no column is provided, returns all mappings\r\n * corresponding to a either the line we are searching for or the next\r\n * closest line that has any mappings. Otherwise, returns all mappings\r\n * corresponding to the given line and either the column we are searching for\r\n * or the next closest column that has any offsets.\r\n *\r\n * The only argument is an object with the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number is 1-based.\r\n *   - column: Optional. the column number in the original source.\r\n *    The column number is 0-based.\r\n *\r\n * and an array of objects is returned, each with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *    line number is 1-based.\r\n *   - column: The column number in the generated source, or null.\r\n *    The column number is 0-based.\r\n */\r\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\r\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\r\n    var line = util.getArg(aArgs, 'line');\r\n\r\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\r\n    // returns the index of the closest mapping less than the needle. By\r\n    // setting needle.originalColumn to 0, we thus find the last mapping for\r\n    // the given line, provided such a mapping exists.\r\n    var needle = {\r\n      source: util.getArg(aArgs, 'source'),\r\n      originalLine: line,\r\n      originalColumn: util.getArg(aArgs, 'column', 0)\r\n    };\r\n\r\n    needle.source = this._findSourceIndex(needle.source);\r\n    if (needle.source < 0) {\r\n      return [];\r\n    }\r\n\r\n    var mappings = [];\r\n\r\n    var index = this._findMapping(needle,\r\n                                  this._originalMappings,\r\n                                  \"originalLine\",\r\n                                  \"originalColumn\",\r\n                                  util.compareByOriginalPositions,\r\n                                  binarySearch.LEAST_UPPER_BOUND);\r\n    if (index >= 0) {\r\n      var mapping = this._originalMappings[index];\r\n\r\n      if (aArgs.column === undefined) {\r\n        var originalLine = mapping.originalLine;\r\n\r\n        // Iterate until either we run out of mappings, or we run into\r\n        // a mapping for a different line than the one we found. Since\r\n        // mappings are sorted, this is guaranteed to find all mappings for\r\n        // the line we found.\r\n        while (mapping && mapping.originalLine === originalLine) {\r\n          mappings.push({\r\n            line: util.getArg(mapping, 'generatedLine', null),\r\n            column: util.getArg(mapping, 'generatedColumn', null),\r\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\r\n          });\r\n\r\n          mapping = this._originalMappings[++index];\r\n        }\r\n      } else {\r\n        var originalColumn = mapping.originalColumn;\r\n\r\n        // Iterate until either we run out of mappings, or we run into\r\n        // a mapping for a different line than the one we were searching for.\r\n        // Since mappings are sorted, this is guaranteed to find all mappings for\r\n        // the line we are searching for.\r\n        while (mapping &&\r\n               mapping.originalLine === line &&\r\n               mapping.originalColumn == originalColumn) {\r\n          mappings.push({\r\n            line: util.getArg(mapping, 'generatedLine', null),\r\n            column: util.getArg(mapping, 'generatedColumn', null),\r\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\r\n          });\r\n\r\n          mapping = this._originalMappings[++index];\r\n        }\r\n      }\r\n    }\r\n\r\n    return mappings;\r\n  };\r\n\r\nexports.SourceMapConsumer = SourceMapConsumer;\r\n\r\n/**\r\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\r\n * query for information about the original file positions by giving it a file\r\n * position in the generated source.\r\n *\r\n * The first parameter is the raw source map (either as a JSON string, or\r\n * already parsed to an object). According to the spec, source maps have the\r\n * following attributes:\r\n *\r\n *   - version: Which version of the source map spec this map is following.\r\n *   - sources: An array of URLs to the original source files.\r\n *   - names: An array of identifiers which can be referenced by individual mappings.\r\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\r\n *   - sourcesContent: Optional. An array of contents of the original source files.\r\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\r\n *   - file: Optional. The generated file this source map is associated with.\r\n *\r\n * Here is an example source map, taken from the source map spec[0]:\r\n *\r\n *     {\r\n *       version : 3,\r\n *       file: \"out.js\",\r\n *       sourceRoot : \"\",\r\n *       sources: [\"foo.js\", \"bar.js\"],\r\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\r\n *       mappings: \"AA,AB;;ABCDE;\"\r\n *     }\r\n *\r\n * The second parameter, if given, is a string whose value is the URL\r\n * at which the source map was found.  This URL is used to compute the\r\n * sources array.\r\n *\r\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\r\n */\r\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === 'string') {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  var version = util.getArg(sourceMap, 'version');\r\n  var sources = util.getArg(sourceMap, 'sources');\r\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\r\n  // requires the array) to play nice here.\r\n  var names = util.getArg(sourceMap, 'names', []);\r\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\r\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\r\n  var mappings = util.getArg(sourceMap, 'mappings');\r\n  var file = util.getArg(sourceMap, 'file', null);\r\n\r\n  // Once again, Sass deviates from the spec and supplies the version as a\r\n  // string rather than a number, so we use loose equality checking here.\r\n  if (version != this._version) {\r\n    throw new Error('Unsupported version: ' + version);\r\n  }\r\n\r\n  if (sourceRoot) {\r\n    sourceRoot = util.normalize(sourceRoot);\r\n  }\r\n\r\n  sources = sources\r\n    .map(String)\r\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\r\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\r\n    // See bugzil.la/1090768.\r\n    .map(util.normalize)\r\n    // Always ensure that absolute sources are internally stored relative to\r\n    // the source root, if the source root is absolute. Not doing this would\r\n    // be particularly problematic when the source root is a prefix of the\r\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\r\n    .map(function (source) {\r\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\r\n        ? util.relative(sourceRoot, source)\r\n        : source;\r\n    });\r\n\r\n  // Pass `true` below to allow duplicate names and sources. While source maps\r\n  // are intended to be compressed and deduplicated, the TypeScript compiler\r\n  // sometimes generates source maps with duplicates in them. See Github issue\r\n  // #72 and bugzil.la/889492.\r\n  this._names = ArraySet.fromArray(names.map(String), true);\r\n  this._sources = ArraySet.fromArray(sources, true);\r\n\r\n  this._absoluteSources = this._sources.toArray().map(function (s) {\r\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\r\n  });\r\n\r\n  this.sourceRoot = sourceRoot;\r\n  this.sourcesContent = sourcesContent;\r\n  this._mappings = mappings;\r\n  this._sourceMapURL = aSourceMapURL;\r\n  this.file = file;\r\n}\r\n\r\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\r\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\r\n\r\n/**\r\n * Utility function to find the index of a source.  Returns -1 if not\r\n * found.\r\n */\r\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\r\n  var relativeSource = aSource;\r\n  if (this.sourceRoot != null) {\r\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\r\n  }\r\n\r\n  if (this._sources.has(relativeSource)) {\r\n    return this._sources.indexOf(relativeSource);\r\n  }\r\n\r\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\r\n  // this case we can't simply undo the transform.\r\n  var i;\r\n  for (i = 0; i < this._absoluteSources.length; ++i) {\r\n    if (this._absoluteSources[i] == aSource) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n};\r\n\r\n/**\r\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\r\n *\r\n * @param SourceMapGenerator aSourceMap\r\n *        The source map that will be consumed.\r\n * @param String aSourceMapURL\r\n *        The URL at which the source map can be found (optional)\r\n * @returns BasicSourceMapConsumer\r\n */\r\nBasicSourceMapConsumer.fromSourceMap =\r\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\r\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\r\n\r\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\r\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\r\n    smc.sourceRoot = aSourceMap._sourceRoot;\r\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\r\n                                                            smc.sourceRoot);\r\n    smc.file = aSourceMap._file;\r\n    smc._sourceMapURL = aSourceMapURL;\r\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\r\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\r\n    });\r\n\r\n    // Because we are modifying the entries (by converting string sources and\r\n    // names to indices into the sources and names ArraySets), we have to make\r\n    // a copy of the entry or else bad things happen. Shared mutable state\r\n    // strikes again! See github issue #191.\r\n\r\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\r\n    var destGeneratedMappings = smc.__generatedMappings = [];\r\n    var destOriginalMappings = smc.__originalMappings = [];\r\n\r\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\r\n      var srcMapping = generatedMappings[i];\r\n      var destMapping = new Mapping;\r\n      destMapping.generatedLine = srcMapping.generatedLine;\r\n      destMapping.generatedColumn = srcMapping.generatedColumn;\r\n\r\n      if (srcMapping.source) {\r\n        destMapping.source = sources.indexOf(srcMapping.source);\r\n        destMapping.originalLine = srcMapping.originalLine;\r\n        destMapping.originalColumn = srcMapping.originalColumn;\r\n\r\n        if (srcMapping.name) {\r\n          destMapping.name = names.indexOf(srcMapping.name);\r\n        }\r\n\r\n        destOriginalMappings.push(destMapping);\r\n      }\r\n\r\n      destGeneratedMappings.push(destMapping);\r\n    }\r\n\r\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\r\n\r\n    return smc;\r\n  };\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nBasicSourceMapConsumer.prototype._version = 3;\r\n\r\n/**\r\n * The list of original sources.\r\n */\r\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\r\n  get: function () {\r\n    return this._absoluteSources.slice();\r\n  }\r\n});\r\n\r\n/**\r\n * Provide the JIT with a nice shape / hidden class.\r\n */\r\nfunction Mapping() {\r\n  this.generatedLine = 0;\r\n  this.generatedColumn = 0;\r\n  this.source = null;\r\n  this.originalLine = null;\r\n  this.originalColumn = null;\r\n  this.name = null;\r\n}\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nBasicSourceMapConsumer.prototype._parseMappings =\r\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\r\n    var generatedLine = 1;\r\n    var previousGeneratedColumn = 0;\r\n    var previousOriginalLine = 0;\r\n    var previousOriginalColumn = 0;\r\n    var previousSource = 0;\r\n    var previousName = 0;\r\n    var length = aStr.length;\r\n    var index = 0;\r\n    var cachedSegments = {};\r\n    var temp = {};\r\n    var originalMappings = [];\r\n    var generatedMappings = [];\r\n    var mapping, str, segment, end, value;\r\n\r\n    while (index < length) {\r\n      if (aStr.charAt(index) === ';') {\r\n        generatedLine++;\r\n        index++;\r\n        previousGeneratedColumn = 0;\r\n      }\r\n      else if (aStr.charAt(index) === ',') {\r\n        index++;\r\n      }\r\n      else {\r\n        mapping = new Mapping();\r\n        mapping.generatedLine = generatedLine;\r\n\r\n        // Because each offset is encoded relative to the previous one,\r\n        // many segments often have the same encoding. We can exploit this\r\n        // fact by caching the parsed variable length fields of each segment,\r\n        // allowing us to avoid a second parse if we encounter the same\r\n        // segment again.\r\n        for (end = index; end < length; end++) {\r\n          if (this._charIsMappingSeparator(aStr, end)) {\r\n            break;\r\n          }\r\n        }\r\n        str = aStr.slice(index, end);\r\n\r\n        segment = cachedSegments[str];\r\n        if (segment) {\r\n          index += str.length;\r\n        } else {\r\n          segment = [];\r\n          while (index < end) {\r\n            base64VLQ.decode(aStr, index, temp);\r\n            value = temp.value;\r\n            index = temp.rest;\r\n            segment.push(value);\r\n          }\r\n\r\n          if (segment.length === 2) {\r\n            throw new Error('Found a source, but no line and column');\r\n          }\r\n\r\n          if (segment.length === 3) {\r\n            throw new Error('Found a source and line, but no column');\r\n          }\r\n\r\n          cachedSegments[str] = segment;\r\n        }\r\n\r\n        // Generated column.\r\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\r\n        previousGeneratedColumn = mapping.generatedColumn;\r\n\r\n        if (segment.length > 1) {\r\n          // Original source.\r\n          mapping.source = previousSource + segment[1];\r\n          previousSource += segment[1];\r\n\r\n          // Original line.\r\n          mapping.originalLine = previousOriginalLine + segment[2];\r\n          previousOriginalLine = mapping.originalLine;\r\n          // Lines are stored 0-based\r\n          mapping.originalLine += 1;\r\n\r\n          // Original column.\r\n          mapping.originalColumn = previousOriginalColumn + segment[3];\r\n          previousOriginalColumn = mapping.originalColumn;\r\n\r\n          if (segment.length > 4) {\r\n            // Original name.\r\n            mapping.name = previousName + segment[4];\r\n            previousName += segment[4];\r\n          }\r\n        }\r\n\r\n        generatedMappings.push(mapping);\r\n        if (typeof mapping.originalLine === 'number') {\r\n          originalMappings.push(mapping);\r\n        }\r\n      }\r\n    }\r\n\r\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\r\n    this.__generatedMappings = generatedMappings;\r\n\r\n    quickSort(originalMappings, util.compareByOriginalPositions);\r\n    this.__originalMappings = originalMappings;\r\n  };\r\n\r\n/**\r\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\r\n * we are searching for in the given \"haystack\" of mappings.\r\n */\r\nBasicSourceMapConsumer.prototype._findMapping =\r\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\r\n                                         aColumnName, aComparator, aBias) {\r\n    // To return the position we are searching for, we must first find the\r\n    // mapping for the given position and then return the opposite position it\r\n    // points to. Because the mappings are sorted, we can use binary search to\r\n    // find the best mapping.\r\n\r\n    if (aNeedle[aLineName] <= 0) {\r\n      throw new TypeError('Line must be greater than or equal to 1, got '\r\n                          + aNeedle[aLineName]);\r\n    }\r\n    if (aNeedle[aColumnName] < 0) {\r\n      throw new TypeError('Column must be greater than or equal to 0, got '\r\n                          + aNeedle[aColumnName]);\r\n    }\r\n\r\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\r\n  };\r\n\r\n/**\r\n * Compute the last column for each generated mapping. The last column is\r\n * inclusive.\r\n */\r\nBasicSourceMapConsumer.prototype.computeColumnSpans =\r\n  function SourceMapConsumer_computeColumnSpans() {\r\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\r\n      var mapping = this._generatedMappings[index];\r\n\r\n      // Mappings do not contain a field for the last generated columnt. We\r\n      // can come up with an optimistic estimate, however, by assuming that\r\n      // mappings are contiguous (i.e. given two consecutive mappings, the\r\n      // first mapping ends where the second one starts).\r\n      if (index + 1 < this._generatedMappings.length) {\r\n        var nextMapping = this._generatedMappings[index + 1];\r\n\r\n        if (mapping.generatedLine === nextMapping.generatedLine) {\r\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // The last mapping for each line spans the entire line.\r\n      mapping.lastGeneratedColumn = Infinity;\r\n    }\r\n  };\r\n\r\n/**\r\n * Returns the original source, line, and column information for the generated\r\n * source's line and column positions provided. The only argument is an object\r\n * with the following properties:\r\n *\r\n *   - line: The line number in the generated source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the generated source.  The column\r\n *     number is 0-based.\r\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\r\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - source: The original source file, or null.\r\n *   - line: The line number in the original source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the original source, or null.  The\r\n *     column number is 0-based.\r\n *   - name: The original identifier, or null.\r\n */\r\nBasicSourceMapConsumer.prototype.originalPositionFor =\r\n  function SourceMapConsumer_originalPositionFor(aArgs) {\r\n    var needle = {\r\n      generatedLine: util.getArg(aArgs, 'line'),\r\n      generatedColumn: util.getArg(aArgs, 'column')\r\n    };\r\n\r\n    var index = this._findMapping(\r\n      needle,\r\n      this._generatedMappings,\r\n      \"generatedLine\",\r\n      \"generatedColumn\",\r\n      util.compareByGeneratedPositionsDeflated,\r\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\r\n    );\r\n\r\n    if (index >= 0) {\r\n      var mapping = this._generatedMappings[index];\r\n\r\n      if (mapping.generatedLine === needle.generatedLine) {\r\n        var source = util.getArg(mapping, 'source', null);\r\n        if (source !== null) {\r\n          source = this._sources.at(source);\r\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\r\n        }\r\n        var name = util.getArg(mapping, 'name', null);\r\n        if (name !== null) {\r\n          name = this._names.at(name);\r\n        }\r\n        return {\r\n          source: source,\r\n          line: util.getArg(mapping, 'originalLine', null),\r\n          column: util.getArg(mapping, 'originalColumn', null),\r\n          name: name\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      source: null,\r\n      line: null,\r\n      column: null,\r\n      name: null\r\n    };\r\n  };\r\n\r\n/**\r\n * Return true if we have the source content for every source in the source\r\n * map, false otherwise.\r\n */\r\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\r\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\r\n    if (!this.sourcesContent) {\r\n      return false;\r\n    }\r\n    return this.sourcesContent.length >= this._sources.size() &&\r\n      !this.sourcesContent.some(function (sc) { return sc == null; });\r\n  };\r\n\r\n/**\r\n * Returns the original source content. The only argument is the url of the\r\n * original source file. Returns null if no original source content is\r\n * available.\r\n */\r\nBasicSourceMapConsumer.prototype.sourceContentFor =\r\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\r\n    if (!this.sourcesContent) {\r\n      return null;\r\n    }\r\n\r\n    var index = this._findSourceIndex(aSource);\r\n    if (index >= 0) {\r\n      return this.sourcesContent[index];\r\n    }\r\n\r\n    var relativeSource = aSource;\r\n    if (this.sourceRoot != null) {\r\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\r\n    }\r\n\r\n    var url;\r\n    if (this.sourceRoot != null\r\n        && (url = util.urlParse(this.sourceRoot))) {\r\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\r\n      // many users. We can help them out when they expect file:// URIs to\r\n      // behave like it would if they were running a local HTTP server. See\r\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\r\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\r\n      if (url.scheme == \"file\"\r\n          && this._sources.has(fileUriAbsPath)) {\r\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\r\n      }\r\n\r\n      if ((!url.path || url.path == \"/\")\r\n          && this._sources.has(\"/\" + relativeSource)) {\r\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\r\n      }\r\n    }\r\n\r\n    // This function is used recursively from\r\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\r\n    // don't want to throw if we can't find the source - we just want to\r\n    // return null, so we provide a flag to exit gracefully.\r\n    if (nullOnMissing) {\r\n      return null;\r\n    }\r\n    else {\r\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\r\n    }\r\n  };\r\n\r\n/**\r\n * Returns the generated line and column information for the original source,\r\n * line, and column positions provided. The only argument is an object with\r\n * the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the original source.  The column\r\n *     number is 0-based.\r\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\r\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\r\n *     closest element that is smaller than or greater than the one we are\r\n *     searching for, respectively, if the exact element cannot be found.\r\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the generated source, or null.\r\n *     The column number is 0-based.\r\n */\r\nBasicSourceMapConsumer.prototype.generatedPositionFor =\r\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\r\n    var source = util.getArg(aArgs, 'source');\r\n    source = this._findSourceIndex(source);\r\n    if (source < 0) {\r\n      return {\r\n        line: null,\r\n        column: null,\r\n        lastColumn: null\r\n      };\r\n    }\r\n\r\n    var needle = {\r\n      source: source,\r\n      originalLine: util.getArg(aArgs, 'line'),\r\n      originalColumn: util.getArg(aArgs, 'column')\r\n    };\r\n\r\n    var index = this._findMapping(\r\n      needle,\r\n      this._originalMappings,\r\n      \"originalLine\",\r\n      \"originalColumn\",\r\n      util.compareByOriginalPositions,\r\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\r\n    );\r\n\r\n    if (index >= 0) {\r\n      var mapping = this._originalMappings[index];\r\n\r\n      if (mapping.source === needle.source) {\r\n        return {\r\n          line: util.getArg(mapping, 'generatedLine', null),\r\n          column: util.getArg(mapping, 'generatedColumn', null),\r\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\r\n        };\r\n      }\r\n    }\r\n\r\n    return {\r\n      line: null,\r\n      column: null,\r\n      lastColumn: null\r\n    };\r\n  };\r\n\r\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\r\n\r\n/**\r\n * An IndexedSourceMapConsumer instance represents a parsed source map which\r\n * we can query for information. It differs from BasicSourceMapConsumer in\r\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\r\n * input.\r\n *\r\n * The first parameter is a raw source map (either as a JSON string, or already\r\n * parsed to an object). According to the spec for indexed source maps, they\r\n * have the following attributes:\r\n *\r\n *   - version: Which version of the source map spec this map is following.\r\n *   - file: Optional. The generated file this source map is associated with.\r\n *   - sections: A list of section definitions.\r\n *\r\n * Each value under the \"sections\" field has two fields:\r\n *   - offset: The offset into the original specified at which this section\r\n *       begins to apply, defined as an object with a \"line\" and \"column\"\r\n *       field.\r\n *   - map: A source map definition. This source map could also be indexed,\r\n *       but doesn't have to be.\r\n *\r\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\r\n * specifying a URL to retrieve a source map from, but that's currently\r\n * unsupported.\r\n *\r\n * Here's an example source map, taken from the source map spec[0], but\r\n * modified to omit a section which uses the \"url\" field.\r\n *\r\n *  {\r\n *    version : 3,\r\n *    file: \"app.js\",\r\n *    sections: [{\r\n *      offset: {line:100, column:10},\r\n *      map: {\r\n *        version : 3,\r\n *        file: \"section.js\",\r\n *        sources: [\"foo.js\", \"bar.js\"],\r\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\r\n *        mappings: \"AAAA,E;;ABCDE;\"\r\n *      }\r\n *    }],\r\n *  }\r\n *\r\n * The second parameter, if given, is a string whose value is the URL\r\n * at which the source map was found.  This URL is used to compute the\r\n * sources array.\r\n *\r\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\r\n */\r\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\r\n  var sourceMap = aSourceMap;\r\n  if (typeof aSourceMap === 'string') {\r\n    sourceMap = util.parseSourceMapInput(aSourceMap);\r\n  }\r\n\r\n  var version = util.getArg(sourceMap, 'version');\r\n  var sections = util.getArg(sourceMap, 'sections');\r\n\r\n  if (version != this._version) {\r\n    throw new Error('Unsupported version: ' + version);\r\n  }\r\n\r\n  this._sources = new ArraySet();\r\n  this._names = new ArraySet();\r\n\r\n  var lastOffset = {\r\n    line: -1,\r\n    column: 0\r\n  };\r\n  this._sections = sections.map(function (s) {\r\n    if (s.url) {\r\n      // The url field will require support for asynchronicity.\r\n      // See https://github.com/mozilla/source-map/issues/16\r\n      throw new Error('Support for url field in sections not implemented.');\r\n    }\r\n    var offset = util.getArg(s, 'offset');\r\n    var offsetLine = util.getArg(offset, 'line');\r\n    var offsetColumn = util.getArg(offset, 'column');\r\n\r\n    if (offsetLine < lastOffset.line ||\r\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\r\n      throw new Error('Section offsets must be ordered and non-overlapping.');\r\n    }\r\n    lastOffset = offset;\r\n\r\n    return {\r\n      generatedOffset: {\r\n        // The offset fields are 0-based, but we use 1-based indices when\r\n        // encoding/decoding from VLQ.\r\n        generatedLine: offsetLine + 1,\r\n        generatedColumn: offsetColumn + 1\r\n      },\r\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\r\n    }\r\n  });\r\n}\r\n\r\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\r\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\r\n\r\n/**\r\n * The version of the source mapping spec that we are consuming.\r\n */\r\nIndexedSourceMapConsumer.prototype._version = 3;\r\n\r\n/**\r\n * The list of original sources.\r\n */\r\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\r\n  get: function () {\r\n    var sources = [];\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\r\n        sources.push(this._sections[i].consumer.sources[j]);\r\n      }\r\n    }\r\n    return sources;\r\n  }\r\n});\r\n\r\n/**\r\n * Returns the original source, line, and column information for the generated\r\n * source's line and column positions provided. The only argument is an object\r\n * with the following properties:\r\n *\r\n *   - line: The line number in the generated source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the generated source.  The column\r\n *     number is 0-based.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - source: The original source file, or null.\r\n *   - line: The line number in the original source, or null.  The\r\n *     line number is 1-based.\r\n *   - column: The column number in the original source, or null.  The\r\n *     column number is 0-based.\r\n *   - name: The original identifier, or null.\r\n */\r\nIndexedSourceMapConsumer.prototype.originalPositionFor =\r\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\r\n    var needle = {\r\n      generatedLine: util.getArg(aArgs, 'line'),\r\n      generatedColumn: util.getArg(aArgs, 'column')\r\n    };\r\n\r\n    // Find the section containing the generated position we're trying to map\r\n    // to an original position.\r\n    var sectionIndex = binarySearch.search(needle, this._sections,\r\n      function(needle, section) {\r\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\r\n        if (cmp) {\r\n          return cmp;\r\n        }\r\n\r\n        return (needle.generatedColumn -\r\n                section.generatedOffset.generatedColumn);\r\n      });\r\n    var section = this._sections[sectionIndex];\r\n\r\n    if (!section) {\r\n      return {\r\n        source: null,\r\n        line: null,\r\n        column: null,\r\n        name: null\r\n      };\r\n    }\r\n\r\n    return section.consumer.originalPositionFor({\r\n      line: needle.generatedLine -\r\n        (section.generatedOffset.generatedLine - 1),\r\n      column: needle.generatedColumn -\r\n        (section.generatedOffset.generatedLine === needle.generatedLine\r\n         ? section.generatedOffset.generatedColumn - 1\r\n         : 0),\r\n      bias: aArgs.bias\r\n    });\r\n  };\r\n\r\n/**\r\n * Return true if we have the source content for every source in the source\r\n * map, false otherwise.\r\n */\r\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\r\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\r\n    return this._sections.every(function (s) {\r\n      return s.consumer.hasContentsOfAllSources();\r\n    });\r\n  };\r\n\r\n/**\r\n * Returns the original source content. The only argument is the url of the\r\n * original source file. Returns null if no original source content is\r\n * available.\r\n */\r\nIndexedSourceMapConsumer.prototype.sourceContentFor =\r\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      var section = this._sections[i];\r\n\r\n      var content = section.consumer.sourceContentFor(aSource, true);\r\n      if (content) {\r\n        return content;\r\n      }\r\n    }\r\n    if (nullOnMissing) {\r\n      return null;\r\n    }\r\n    else {\r\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\r\n    }\r\n  };\r\n\r\n/**\r\n * Returns the generated line and column information for the original source,\r\n * line, and column positions provided. The only argument is an object with\r\n * the following properties:\r\n *\r\n *   - source: The filename of the original source.\r\n *   - line: The line number in the original source.  The line number\r\n *     is 1-based.\r\n *   - column: The column number in the original source.  The column\r\n *     number is 0-based.\r\n *\r\n * and an object is returned with the following properties:\r\n *\r\n *   - line: The line number in the generated source, or null.  The\r\n *     line number is 1-based. \r\n *   - column: The column number in the generated source, or null.\r\n *     The column number is 0-based.\r\n */\r\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\r\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      var section = this._sections[i];\r\n\r\n      // Only consider this section if the requested source is in the list of\r\n      // sources of the consumer.\r\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\r\n        continue;\r\n      }\r\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\r\n      if (generatedPosition) {\r\n        var ret = {\r\n          line: generatedPosition.line +\r\n            (section.generatedOffset.generatedLine - 1),\r\n          column: generatedPosition.column +\r\n            (section.generatedOffset.generatedLine === generatedPosition.line\r\n             ? section.generatedOffset.generatedColumn - 1\r\n             : 0)\r\n        };\r\n        return ret;\r\n      }\r\n    }\r\n\r\n    return {\r\n      line: null,\r\n      column: null\r\n    };\r\n  };\r\n\r\n/**\r\n * Parse the mappings in a string in to a data structure which we can easily\r\n * query (the ordered arrays in the `this.__generatedMappings` and\r\n * `this.__originalMappings` properties).\r\n */\r\nIndexedSourceMapConsumer.prototype._parseMappings =\r\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\r\n    this.__generatedMappings = [];\r\n    this.__originalMappings = [];\r\n    for (var i = 0; i < this._sections.length; i++) {\r\n      var section = this._sections[i];\r\n      var sectionMappings = section.consumer._generatedMappings;\r\n      for (var j = 0; j < sectionMappings.length; j++) {\r\n        var mapping = sectionMappings[j];\r\n\r\n        var source = section.consumer._sources.at(mapping.source);\r\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\r\n        this._sources.add(source);\r\n        source = this._sources.indexOf(source);\r\n\r\n        var name = null;\r\n        if (mapping.name) {\r\n          name = section.consumer._names.at(mapping.name);\r\n          this._names.add(name);\r\n          name = this._names.indexOf(name);\r\n        }\r\n\r\n        // The mappings coming from the consumer for the section have\r\n        // generated positions relative to the start of the section, so we\r\n        // need to offset them to be relative to the start of the concatenated\r\n        // generated file.\r\n        var adjustedMapping = {\r\n          source: source,\r\n          generatedLine: mapping.generatedLine +\r\n            (section.generatedOffset.generatedLine - 1),\r\n          generatedColumn: mapping.generatedColumn +\r\n            (section.generatedOffset.generatedLine === mapping.generatedLine\r\n            ? section.generatedOffset.generatedColumn - 1\r\n            : 0),\r\n          originalLine: mapping.originalLine,\r\n          originalColumn: mapping.originalColumn,\r\n          name: name\r\n        };\r\n\r\n        this.__generatedMappings.push(adjustedMapping);\r\n        if (typeof adjustedMapping.originalLine === 'number') {\r\n          this.__originalMappings.push(adjustedMapping);\r\n        }\r\n      }\r\n    }\r\n\r\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\r\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\r\n  };\r\n\r\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2014 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar util = require('./util');\r\n\r\n/**\r\n * Determine whether mappingB is after mappingA with respect to generated\r\n * position.\r\n */\r\nfunction generatedPositionAfter(mappingA, mappingB) {\r\n  // Optimized for most common case\r\n  var lineA = mappingA.generatedLine;\r\n  var lineB = mappingB.generatedLine;\r\n  var columnA = mappingA.generatedColumn;\r\n  var columnB = mappingB.generatedColumn;\r\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\r\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\r\n}\r\n\r\n/**\r\n * A data structure to provide a sorted view of accumulated mappings in a\r\n * performance conscious manner. It trades a negligible overhead in general\r\n * case for a large speedup in case of mappings being added in order.\r\n */\r\nfunction MappingList() {\r\n  this._array = [];\r\n  this._sorted = true;\r\n  // Serves as infimum\r\n  this._last = {generatedLine: -1, generatedColumn: 0};\r\n}\r\n\r\n/**\r\n * Iterate through internal items. This method takes the same arguments that\r\n * `Array.prototype.forEach` takes.\r\n *\r\n * NOTE: The order of the mappings is NOT guaranteed.\r\n */\r\nMappingList.prototype.unsortedForEach =\r\n  function MappingList_forEach(aCallback, aThisArg) {\r\n    this._array.forEach(aCallback, aThisArg);\r\n  };\r\n\r\n/**\r\n * Add the given source mapping.\r\n *\r\n * @param Object aMapping\r\n */\r\nMappingList.prototype.add = function MappingList_add(aMapping) {\r\n  if (generatedPositionAfter(this._last, aMapping)) {\r\n    this._last = aMapping;\r\n    this._array.push(aMapping);\r\n  } else {\r\n    this._sorted = false;\r\n    this._array.push(aMapping);\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the flat, sorted array of mappings. The mappings are sorted by\r\n * generated position.\r\n *\r\n * WARNING: This method returns internal data without copying, for\r\n * performance. The return value must NOT be mutated, and should be treated as\r\n * an immutable borrow. If you want to take ownership, you must make your own\r\n * copy.\r\n */\r\nMappingList.prototype.toArray = function MappingList_toArray() {\r\n  if (!this._sorted) {\r\n    this._array.sort(util.compareByGeneratedPositionsInflated);\r\n    this._sorted = true;\r\n  }\r\n  return this._array;\r\n};\r\n\r\nexports.MappingList = MappingList;\r\n","/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\r\n\r\n/**\r\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\r\n */\r\nexports.encode = function (number) {\r\n  if (0 <= number && number < intToCharMap.length) {\r\n    return intToCharMap[number];\r\n  }\r\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\r\n};\r\n\r\n/**\r\n * Decode a single base 64 character code digit to an integer. Returns -1 on\r\n * failure.\r\n */\r\nexports.decode = function (charCode) {\r\n  var bigA = 65;     // 'A'\r\n  var bigZ = 90;     // 'Z'\r\n\r\n  var littleA = 97;  // 'a'\r\n  var littleZ = 122; // 'z'\r\n\r\n  var zero = 48;     // '0'\r\n  var nine = 57;     // '9'\r\n\r\n  var plus = 43;     // '+'\r\n  var slash = 47;    // '/'\r\n\r\n  var littleOffset = 26;\r\n  var numberOffset = 52;\r\n\r\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n  if (bigA <= charCode && charCode <= bigZ) {\r\n    return (charCode - bigA);\r\n  }\r\n\r\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\r\n  if (littleA <= charCode && charCode <= littleZ) {\r\n    return (charCode - littleA + littleOffset);\r\n  }\r\n\r\n  // 52 - 61: 0123456789\r\n  if (zero <= charCode && charCode <= nine) {\r\n    return (charCode - zero + numberOffset);\r\n  }\r\n\r\n  // 62: +\r\n  if (charCode == plus) {\r\n    return 62;\r\n  }\r\n\r\n  // 63: /\r\n  if (charCode == slash) {\r\n    return 63;\r\n  }\r\n\r\n  // Invalid base64 digit.\r\n  return -1;\r\n};\r\n","/*\r\n * Copyright 2009-2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE.txt or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\r\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\r\nexports.SourceNode = require('./lib/source-node').SourceNode;\r\n"],"sourceRoot":""}